/*
Smart Hands

Request cage assistance, custom installation and equipment troubleshooting.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package smarthandsv1

import (
	"encoding/json"
	"fmt"
)

// ScheduleInfoScheduleType <u>STANDARD:</u> <br>Choose this option and we will complete your request in the standard turnaround time pending install base readiness. Most requests are processed within 24 to 72 hours. Requests will be processed on a first come, first served basis unless they are expedited. RequestedStartDate and requestedCompletionDate ignored for standard scheduling <br><br> <u>EXPEDITED:</u> Choose this option and Equinix will prioritize your request and attempt to fulfill it as soon as reasonably possible. Additional fees may apply. RequestedCompletionDate is mandatory for expedite scheduling. RequestedStartDate is ignored for expedite scheduling. <br><br> <u>SCHEDULED_MAINTENANCE:</u> Choose this option to schedule a request for a specific date and time, including today. RequestedStartDate and requestedCompletionDate are mandatory for schedule maintenance
type ScheduleInfoScheduleType string

// List of scheduleInfo_scheduleType
const (
	SCHEDULEINFOSCHEDULETYPE_STANDARD              ScheduleInfoScheduleType = "STANDARD"
	SCHEDULEINFOSCHEDULETYPE_EXPEDITED             ScheduleInfoScheduleType = "EXPEDITED"
	SCHEDULEINFOSCHEDULETYPE_SCHEDULED_MAINTENANCE ScheduleInfoScheduleType = "SCHEDULED_MAINTENANCE"
)

// All allowed values of ScheduleInfoScheduleType enum
var AllowedScheduleInfoScheduleTypeEnumValues = []ScheduleInfoScheduleType{
	"STANDARD",
	"EXPEDITED",
	"SCHEDULED_MAINTENANCE",
}

func (v *ScheduleInfoScheduleType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ScheduleInfoScheduleType(value)
	for _, existing := range AllowedScheduleInfoScheduleTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ScheduleInfoScheduleType", value)
}

// NewScheduleInfoScheduleTypeFromValue returns a pointer to a valid ScheduleInfoScheduleType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewScheduleInfoScheduleTypeFromValue(v string) (*ScheduleInfoScheduleType, error) {
	ev := ScheduleInfoScheduleType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ScheduleInfoScheduleType: valid values are %v", v, AllowedScheduleInfoScheduleTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ScheduleInfoScheduleType) IsValid() bool {
	for _, existing := range AllowedScheduleInfoScheduleTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to scheduleInfo_scheduleType value
func (v ScheduleInfoScheduleType) Ptr() *ScheduleInfoScheduleType {
	return &v
}

type NullableScheduleInfoScheduleType struct {
	value *ScheduleInfoScheduleType
	isSet bool
}

func (v NullableScheduleInfoScheduleType) Get() *ScheduleInfoScheduleType {
	return v.value
}

func (v *NullableScheduleInfoScheduleType) Set(val *ScheduleInfoScheduleType) {
	v.value = val
	v.isSet = true
}

func (v NullableScheduleInfoScheduleType) IsSet() bool {
	return v.isSet
}

func (v *NullableScheduleInfoScheduleType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableScheduleInfoScheduleType(val *ScheduleInfoScheduleType) *NullableScheduleInfoScheduleType {
	return &NullableScheduleInfoScheduleType{value: val, isSet: true}
}

func (v NullableScheduleInfoScheduleType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableScheduleInfoScheduleType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
