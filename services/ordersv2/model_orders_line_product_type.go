/*
Orders

Based on a user's permission, a user may be able to view their own orders or also the orders from all of the users in their organization. These orders can be filtered by product type, order status, location, or date range. Only orders from the past 12 months will be returned.

API version: 2.0-beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ordersv2

import (
	"encoding/json"
	"fmt"
)

// OrdersLineProductType Type of product
type OrdersLineProductType string

// List of ordersLine_productType
const (
	ORDERSLINEPRODUCTTYPE_CROSS_CONNECT           OrdersLineProductType = "CROSS_CONNECT"
	ORDERSLINEPRODUCTTYPE_SMART_HANDS             OrdersLineProductType = "SMART_HANDS"
	ORDERSLINEPRODUCTTYPE_WORK_VISIT              OrdersLineProductType = "WORK_VISIT"
	ORDERSLINEPRODUCTTYPE_SECURITY_ACCESS         OrdersLineProductType = "SECURITY_ACCESS"
	ORDERSLINEPRODUCTTYPE_CONFERENCE_ROOM         OrdersLineProductType = "CONFERENCE_ROOM"
	ORDERSLINEPRODUCTTYPE_TROUBLE_TICKET          OrdersLineProductType = "TROUBLE_TICKET"
	ORDERSLINEPRODUCTTYPE_SHIPMENTS               OrdersLineProductType = "SHIPMENTS"
	ORDERSLINEPRODUCTTYPE_NETWORK_PORTS           OrdersLineProductType = "NETWORK_PORTS"
	ORDERSLINEPRODUCTTYPE_DEINSTALL_CROSS_CONNECT OrdersLineProductType = "DEINSTALL_CROSS_CONNECT"
	ORDERSLINEPRODUCTTYPE_OTHER                   OrdersLineProductType = "OTHER"
)

// All allowed values of OrdersLineProductType enum
var AllowedOrdersLineProductTypeEnumValues = []OrdersLineProductType{
	"CROSS_CONNECT",
	"SMART_HANDS",
	"WORK_VISIT",
	"SECURITY_ACCESS",
	"CONFERENCE_ROOM",
	"TROUBLE_TICKET",
	"SHIPMENTS",
	"NETWORK_PORTS",
	"DEINSTALL_CROSS_CONNECT",
	"OTHER",
}

func (v *OrdersLineProductType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := OrdersLineProductType(value)
	for _, existing := range AllowedOrdersLineProductTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid OrdersLineProductType", value)
}

// NewOrdersLineProductTypeFromValue returns a pointer to a valid OrdersLineProductType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewOrdersLineProductTypeFromValue(v string) (*OrdersLineProductType, error) {
	ev := OrdersLineProductType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for OrdersLineProductType: valid values are %v", v, AllowedOrdersLineProductTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v OrdersLineProductType) IsValid() bool {
	for _, existing := range AllowedOrdersLineProductTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ordersLine_productType value
func (v OrdersLineProductType) Ptr() *OrdersLineProductType {
	return &v
}

type NullableOrdersLineProductType struct {
	value *OrdersLineProductType
	isSet bool
}

func (v NullableOrdersLineProductType) Get() *OrdersLineProductType {
	return v.value
}

func (v *NullableOrdersLineProductType) Set(val *OrdersLineProductType) {
	v.value = val
	v.isSet = true
}

func (v NullableOrdersLineProductType) IsSet() bool {
	return v.isSet
}

func (v *NullableOrdersLineProductType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableOrdersLineProductType(val *OrdersLineProductType) *NullableOrdersLineProductType {
	return &NullableOrdersLineProductType{value: val, isSet: true}
}

func (v NullableOrdersLineProductType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableOrdersLineProductType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
