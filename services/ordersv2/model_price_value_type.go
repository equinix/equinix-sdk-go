/*
Orders

Based on a user's permission, a user may be able to view their own orders or also the orders from all of the users in their organization. These orders can be filtered by product type, order status, location, or date range. Only orders from the past 12 months will be returned.

API version: 2.0-beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ordersv2

import (
	"encoding/json"
	"fmt"
)

// PriceValueType To indicate if `value` is of absolute or percentage value. i.e Use ABSOLUTE for $50 or PERCENTAGE for 50%
type PriceValueType string

// List of price_valueType
const (
	PRICEVALUETYPE_ABSOLUTE   PriceValueType = "ABSOLUTE"
	PRICEVALUETYPE_PERCENTAGE PriceValueType = "PERCENTAGE"
)

// All allowed values of PriceValueType enum
var AllowedPriceValueTypeEnumValues = []PriceValueType{
	"ABSOLUTE",
	"PERCENTAGE",
}

func (v *PriceValueType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := PriceValueType(value)
	for _, existing := range AllowedPriceValueTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid PriceValueType", value)
}

// NewPriceValueTypeFromValue returns a pointer to a valid PriceValueType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewPriceValueTypeFromValue(v string) (*PriceValueType, error) {
	ev := PriceValueType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for PriceValueType: valid values are %v", v, AllowedPriceValueTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v PriceValueType) IsValid() bool {
	for _, existing := range AllowedPriceValueTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to price_valueType value
func (v PriceValueType) Ptr() *PriceValueType {
	return &v
}

type NullablePriceValueType struct {
	value *PriceValueType
	isSet bool
}

func (v NullablePriceValueType) Get() *PriceValueType {
	return v.value
}

func (v *NullablePriceValueType) Set(val *PriceValueType) {
	v.value = val
	v.isSet = true
}

func (v NullablePriceValueType) IsSet() bool {
	return v.isSet
}

func (v *NullablePriceValueType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePriceValueType(val *PriceValueType) *NullablePriceValueType {
	return &NullablePriceValueType{value: val, isSet: true}
}

func (v NullablePriceValueType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePriceValueType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
