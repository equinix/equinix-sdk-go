/*
Orders

Based on a user's permission, a user may be able to view their own orders or also the orders from all of the users in their organization. These orders can be filtered by product type, order status, location, or date range. Only orders from the past 12 months will be returned.

API version: 2.0-beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ordersv2

import (
	"encoding/json"
	"fmt"
)

// PriceType To indicate the type of `value` and `valueType`.
type PriceType string

// List of price_type
const (
	PRICETYPE_ONE_TIME_CHARGE   PriceType = "ONE_TIME_CHARGE"
	PRICETYPE_MONTHLY_CHARGE    PriceType = "MONTHLY_CHARGE"
	PRICETYPE_MONTHLY_DISCOUNT  PriceType = "MONTHLY_DISCOUNT"
	PRICETYPE_ONE_TIME_DISCOUNT PriceType = "ONE_TIME_DISCOUNT"
)

// All allowed values of PriceType enum
var AllowedPriceTypeEnumValues = []PriceType{
	"ONE_TIME_CHARGE",
	"MONTHLY_CHARGE",
	"MONTHLY_DISCOUNT",
	"ONE_TIME_DISCOUNT",
}

func (v *PriceType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := PriceType(value)
	for _, existing := range AllowedPriceTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid PriceType", value)
}

// NewPriceTypeFromValue returns a pointer to a valid PriceType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewPriceTypeFromValue(v string) (*PriceType, error) {
	ev := PriceType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for PriceType: valid values are %v", v, AllowedPriceTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v PriceType) IsValid() bool {
	for _, existing := range AllowedPriceTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to price_type value
func (v PriceType) Ptr() *PriceType {
	return &v
}

type NullablePriceType struct {
	value *PriceType
	isSet bool
}

func (v NullablePriceType) Get() *PriceType {
	return v.value
}

func (v *NullablePriceType) Set(val *PriceType) {
	v.value = val
	v.isSet = true
}

func (v NullablePriceType) IsSet() bool {
	return v.isSet
}

func (v *NullablePriceType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePriceType(val *PriceType) *NullablePriceType {
	return &NullablePriceType{value: val, isSet: true}
}

func (v NullablePriceType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePriceType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
