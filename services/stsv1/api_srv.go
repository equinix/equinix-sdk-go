/*
Equinix Security Token Service

Exchange ID tokens for Equinix access tokens according to managed trust relationships.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stsv1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SrvApiService SrvApi service
type SrvApiService service

type ApiSrvGetServiceIdTokenPostRequest struct {
	ctx context.Context
	ApiService *SrvApiService
	srvGetServiceIdTokenPostRequest *SrvGetServiceIdTokenPostRequest
}

func (r ApiSrvGetServiceIdTokenPostRequest) SrvGetServiceIdTokenPostRequest(srvGetServiceIdTokenPostRequest SrvGetServiceIdTokenPostRequest) ApiSrvGetServiceIdTokenPostRequest {
	r.srvGetServiceIdTokenPostRequest = &srvGetServiceIdTokenPostRequest
	return r
}

func (r ApiSrvGetServiceIdTokenPostRequest) Execute() (*SrvGetServiceIdTokenPost200Response, *http.Response, error) {
	return r.ApiService.SrvGetServiceIdTokenPostExecute(r)
}

/*
SrvGetServiceIdTokenPost /srv/getServiceIdToken

Request an OIDC ID token that identifies the service in the context of a specific project, and
  with one or more audiences as the intended recipients. This action may *only* be used by service
  principals. Its purpose is to enable OIDC-based federated access to 3rd party systems
  on behalf of the owners of a specific project.

  On success, the returned ID token is valid for 5 minutes. Its `sub` claim has the form

    principal:{serviceId}:{projectId}

  and its `aud` claim is equal to the supplied `audiences` value.

  The service and project id values include their prefixes, so a principal might look like this:

    principal:service:equinix/ecns:project:abec24ac-759f-47da-8823-72f2b0122e75

  Access control is based on the service that corresponds to the principal in the auth token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSrvGetServiceIdTokenPostRequest
*/
func (a *SrvApiService) SrvGetServiceIdTokenPost(ctx context.Context) ApiSrvGetServiceIdTokenPostRequest {
	return ApiSrvGetServiceIdTokenPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SrvGetServiceIdTokenPost200Response
func (a *SrvApiService) SrvGetServiceIdTokenPostExecute(r ApiSrvGetServiceIdTokenPostRequest) (*SrvGetServiceIdTokenPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SrvGetServiceIdTokenPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SrvApiService.SrvGetServiceIdTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/srv/getServiceIdToken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.srvGetServiceIdTokenPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSrvListClientRegistrationsPostRequest struct {
	ctx context.Context
	ApiService *SrvApiService
	srvListClientRegistrationsPostRequest *SrvListClientRegistrationsPostRequest
}

func (r ApiSrvListClientRegistrationsPostRequest) SrvListClientRegistrationsPostRequest(srvListClientRegistrationsPostRequest SrvListClientRegistrationsPostRequest) ApiSrvListClientRegistrationsPostRequest {
	r.srvListClientRegistrationsPostRequest = &srvListClientRegistrationsPostRequest
	return r
}

func (r ApiSrvListClientRegistrationsPostRequest) Execute() (*SrvListClientRegistrationsPost200Response, *http.Response, error) {
	return r.ApiService.SrvListClientRegistrationsPostExecute(r)
}

/*
SrvListClientRegistrationsPost /srv/listClientRegistrations

Allows a service developer to page through the clients that are registered for a given service. The service is
  identified by either the `serviceId` or `serviceErn` parameters. If the `serviceId` parameter is used then the service
  must be owned by the same project that owns the access policy being used to invoke this operation. The clients listed
  are those which can use the OAuth client credentials flow to obtain access tokens. Access control is based on the
  service for which a client is being registered.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSrvListClientRegistrationsPostRequest
*/
func (a *SrvApiService) SrvListClientRegistrationsPost(ctx context.Context) ApiSrvListClientRegistrationsPostRequest {
	return ApiSrvListClientRegistrationsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SrvListClientRegistrationsPost200Response
func (a *SrvApiService) SrvListClientRegistrationsPostExecute(r ApiSrvListClientRegistrationsPostRequest) (*SrvListClientRegistrationsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SrvListClientRegistrationsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SrvApiService.SrvListClientRegistrationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/srv/listClientRegistrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.srvListClientRegistrationsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSrvRegisterClientPostRequest struct {
	ctx context.Context
	ApiService *SrvApiService
	srvRegisterClientPostRequest *SrvRegisterClientPostRequest
}

func (r ApiSrvRegisterClientPostRequest) SrvRegisterClientPostRequest(srvRegisterClientPostRequest SrvRegisterClientPostRequest) ApiSrvRegisterClientPostRequest {
	r.srvRegisterClientPostRequest = &srvRegisterClientPostRequest
	return r
}

func (r ApiSrvRegisterClientPostRequest) Execute() (*SrvRegisterClientPost200Response, *http.Response, error) {
	return r.ApiService.SrvRegisterClientPostExecute(r)
}

/*
SrvRegisterClientPost /srv/registerClient

Allows a service developer to register a new client for a given service. The service is identified by either the
  `serviceId` or `serviceErn` parameters. If the `serviceId` parameter is used then the service must be owned by the
  same project that owns the access policy being used to invoke this operation. Registering a client enables caller to
  use the OAuth client credentials flow to obtain an access token. Access control is based on the service for which a
  client is being registered.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSrvRegisterClientPostRequest
*/
func (a *SrvApiService) SrvRegisterClientPost(ctx context.Context) ApiSrvRegisterClientPostRequest {
	return ApiSrvRegisterClientPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SrvRegisterClientPost200Response
func (a *SrvApiService) SrvRegisterClientPostExecute(r ApiSrvRegisterClientPostRequest) (*SrvRegisterClientPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SrvRegisterClientPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SrvApiService.SrvRegisterClientPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/srv/registerClient"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.srvRegisterClientPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
