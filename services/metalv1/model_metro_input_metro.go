/*
Metal API

Contact: support@equinixmetal.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metalv1

import (
	"encoding/json"
	"fmt"
)

// MetroInputMetro Metro code or ID of where the device should be provisioned in, or it can be instructed to create the device in the best available metro with `{ \"metro\": \"any\" }`. The special metro value of any means anywhere, any metro. When any is chosen in the request, the metro location is picked per our scheduling algorithms that favor the following factors: hardware reservation location (if requesting reserved hardware), ip reservations, spot instances, etc. The any keyword *does not* optimize for cost, this means that usage costs (instance, transfer, other features dependent on location) will vary. Please check metro value in response to see where the device was created.  Additionally it is possible to set a prioritized location selection. For example `{ \"metro\": [\"m3\", \"m2\", \"any\"] }` can be used to prioritize `m3` and then `m2` before accepting `any` metro. If none of the metros provided have availability for the requested device the request will fail. Either metro or facility must be provided.
type MetroInputMetro struct {
	ArrayOfString *[]string
	String        *string
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *MetroInputMetro) UnmarshalJSON(data []byte) error {
	var err error
	// try to unmarshal JSON data into ArrayOfString
	err = json.Unmarshal(data, &dst.ArrayOfString)
	if err == nil {
		jsonArrayOfString, _ := json.Marshal(dst.ArrayOfString)
		if string(jsonArrayOfString) == "{}" { // empty struct
			dst.ArrayOfString = nil
		} else {
			return nil // data stored in dst.ArrayOfString, return on the first match
		}
	} else {
		dst.ArrayOfString = nil
	}

	// try to unmarshal JSON data into String
	err = json.Unmarshal(data, &dst.String)
	if err == nil {
		jsonString, _ := json.Marshal(dst.String)
		if string(jsonString) == "{}" { // empty struct
			dst.String = nil
		} else {
			return nil // data stored in dst.String, return on the first match
		}
	} else {
		dst.String = nil
	}

	return fmt.Errorf("data failed to match schemas in anyOf(MetroInputMetro)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src *MetroInputMetro) MarshalJSON() ([]byte, error) {
	if src.ArrayOfString != nil {
		return json.Marshal(&src.ArrayOfString)
	}

	if src.String != nil {
		return json.Marshal(&src.String)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableMetroInputMetro struct {
	value *MetroInputMetro
	isSet bool
}

func (v NullableMetroInputMetro) Get() *MetroInputMetro {
	return v.value
}

func (v *NullableMetroInputMetro) Set(val *MetroInputMetro) {
	v.value = val
	v.isSet = true
}

func (v NullableMetroInputMetro) IsSet() bool {
	return v.isSet
}

func (v *NullableMetroInputMetro) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableMetroInputMetro(val *MetroInputMetro) *NullableMetroInputMetro {
	return &NullableMetroInputMetro{value: val, isSet: true}
}

func (v NullableMetroInputMetro) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableMetroInputMetro) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
