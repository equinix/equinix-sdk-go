/*
Network Edge APIs

Network Edge (NE) is a platform that allows customers to deploy and run virtual network services and appliances such as routers, load balancers, and firewalls on a generic device instead of additional dedicated hardware, CapEx and colo space. The Network Edge REST APIs allow you to interact with the Equinix Platform to programmatically create a virtual device and add services. Details on specific use cases can be found in the documentation available on the developer portal.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package networkedgev1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// SetupApiService SetupApi service
type SetupApiService service

type ApiGetAccountsWithStatusUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SetupApiService
	metro         string
	authorization *string
	accountUcmId  *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetAccountsWithStatusUsingGETRequest) Authorization(authorization string) ApiGetAccountsWithStatusUsingGETRequest {
	r.authorization = &authorization
	return r
}

// Unique ID of an account
func (r ApiGetAccountsWithStatusUsingGETRequest) AccountUcmId(accountUcmId string) ApiGetAccountsWithStatusUsingGETRequest {
	r.accountUcmId = &accountUcmId
	return r
}

func (r ApiGetAccountsWithStatusUsingGETRequest) Execute() (*PageResponseDtoMetroAccountResponse, *http.Response, error) {
	return r.ApiService.GetAccountsWithStatusUsingGETExecute(r)
}

/*
GetAccountsWithStatusUsingGET Get Accounts {metro}

Gets accounts by metro. You must have an account in a metro to create a virtual device there. To create an account go to "accountCreateUrl".

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metro Metro region for which you want to check your account status
	@return ApiGetAccountsWithStatusUsingGETRequest
*/
func (a *SetupApiService) GetAccountsWithStatusUsingGET(ctx context.Context, metro string) ApiGetAccountsWithStatusUsingGETRequest {
	return ApiGetAccountsWithStatusUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		metro:      metro,
	}
}

// Execute executes the request
//
//	@return PageResponseDtoMetroAccountResponse
func (a *SetupApiService) GetAccountsWithStatusUsingGETExecute(r ApiGetAccountsWithStatusUsingGETRequest) (*PageResponseDtoMetroAccountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageResponseDtoMetroAccountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetAccountsWithStatusUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/accounts/{metro}"
	localVarPath = strings.Replace(localVarPath, "{"+"metro"+"}", url.PathEscape(parameterValueToString(r.metro, "metro")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.accountUcmId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountUcmId", r.accountUcmId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgreementStatusUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SetupApiService
	accountNumber *string
	authorization *string
}

// account_number
func (r ApiGetAgreementStatusUsingGETRequest) AccountNumber(accountNumber string) ApiGetAgreementStatusUsingGETRequest {
	r.accountNumber = &accountNumber
	return r
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetAgreementStatusUsingGETRequest) Authorization(authorization string) ApiGetAgreementStatusUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetAgreementStatusUsingGETRequest) Execute() (*AgreementStatusResponse, *http.Response, error) {
	return r.ApiService.GetAgreementStatusUsingGETExecute(r)
}

/*
GetAgreementStatusUsingGET Get Agreement Status.

Call this API to find out the status of your agreement, whether it is valid or not, or to just read the agreement terms.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAgreementStatusUsingGETRequest
*/
func (a *SetupApiService) GetAgreementStatusUsingGET(ctx context.Context) ApiGetAgreementStatusUsingGETRequest {
	return ApiGetAgreementStatusUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgreementStatusResponse
func (a *SetupApiService) GetAgreementStatusUsingGETExecute(r ApiGetAgreementStatusUsingGETRequest) (*AgreementStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgreementStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetAgreementStatusUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/agreements/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountNumber == nil {
		return localVarReturnValue, nil, reportError("accountNumber is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "account_number", r.accountNumber, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllowedInterfacesUsingGETRequest struct {
	ctx                  context.Context
	ApiService           *SetupApiService
	deviceType           string
	deviceManagementType *string
	core                 *int32
	authorization        *string
	mode                 *string
	cluster              *bool
	sdwan                *bool
	connectivity         *string
	memory               *int32
	unit                 *string
	flavor               *string
	version              *string
	softwarePkg          *string
}

// Device management type. SELF-CONFIGURED
func (r ApiGetAllowedInterfacesUsingGETRequest) DeviceManagementType(deviceManagementType string) ApiGetAllowedInterfacesUsingGETRequest {
	r.deviceManagementType = &deviceManagementType
	return r
}

// The desired number of cores.
func (r ApiGetAllowedInterfacesUsingGETRequest) Core(core int32) ApiGetAllowedInterfacesUsingGETRequest {
	r.core = &core
	return r
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetAllowedInterfacesUsingGETRequest) Authorization(authorization string) ApiGetAllowedInterfacesUsingGETRequest {
	r.authorization = &authorization
	return r
}

// License mode, either Subscription or BYOL.
func (r ApiGetAllowedInterfacesUsingGETRequest) Mode(mode string) ApiGetAllowedInterfacesUsingGETRequest {
	r.mode = &mode
	return r
}

// Whether you want a cluster device.
func (r ApiGetAllowedInterfacesUsingGETRequest) Cluster(cluster bool) ApiGetAllowedInterfacesUsingGETRequest {
	r.cluster = &cluster
	return r
}

// Whether you want an SD-WAN device.
func (r ApiGetAllowedInterfacesUsingGETRequest) Sdwan(sdwan bool) ApiGetAllowedInterfacesUsingGETRequest {
	r.sdwan = &sdwan
	return r
}

// Type of connectivity you want. INTERNET-ACCESS, PRIVATE, or INTERNET-ACCESS-WITH-PRVT-MGMT. PRIVATE devices do not have ACLs or bandwidth.
func (r ApiGetAllowedInterfacesUsingGETRequest) Connectivity(connectivity string) ApiGetAllowedInterfacesUsingGETRequest {
	r.connectivity = &connectivity
	return r
}

// Desired memory.
func (r ApiGetAllowedInterfacesUsingGETRequest) Memory(memory int32) ApiGetAllowedInterfacesUsingGETRequest {
	r.memory = &memory
	return r
}

// Unit of memory. GB or MB.
func (r ApiGetAllowedInterfacesUsingGETRequest) Unit(unit string) ApiGetAllowedInterfacesUsingGETRequest {
	r.unit = &unit
	return r
}

// Flavor of device.
func (r ApiGetAllowedInterfacesUsingGETRequest) Flavor(flavor string) ApiGetAllowedInterfacesUsingGETRequest {
	r.flavor = &flavor
	return r
}

// Version.
func (r ApiGetAllowedInterfacesUsingGETRequest) Version(version string) ApiGetAllowedInterfacesUsingGETRequest {
	r.version = &version
	return r
}

// Software package.
func (r ApiGetAllowedInterfacesUsingGETRequest) SoftwarePkg(softwarePkg string) ApiGetAllowedInterfacesUsingGETRequest {
	r.softwarePkg = &softwarePkg
	return r
}

func (r ApiGetAllowedInterfacesUsingGETRequest) Execute() (*AllowedInterfaceResponse, *http.Response, error) {
	return r.ApiService.GetAllowedInterfacesUsingGETExecute(r)
}

/*
GetAllowedInterfacesUsingGET Get Allowed Interfaces

Returns the interface details for a device type with a chosen configuration. You must pass the device type as the path parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceType Device type code. PA-VM.
	@return ApiGetAllowedInterfacesUsingGETRequest
*/
func (a *SetupApiService) GetAllowedInterfacesUsingGET(ctx context.Context, deviceType string) ApiGetAllowedInterfacesUsingGETRequest {
	return ApiGetAllowedInterfacesUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		deviceType: deviceType,
	}
}

// Execute executes the request
//
//	@return AllowedInterfaceResponse
func (a *SetupApiService) GetAllowedInterfacesUsingGETExecute(r ApiGetAllowedInterfacesUsingGETRequest) (*AllowedInterfaceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AllowedInterfaceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetAllowedInterfacesUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/deviceTypes/{deviceType}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceType"+"}", url.PathEscape(parameterValueToString(r.deviceType, "deviceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceManagementType == nil {
		return localVarReturnValue, nil, reportError("deviceManagementType is required and must be specified")
	}
	if r.core == nil {
		return localVarReturnValue, nil, reportError("core is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceManagementType", r.deviceManagementType, "")
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.sdwan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sdwan", r.sdwan, "")
	}
	if r.connectivity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectivity", r.connectivity, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "core", r.core, "")
	if r.memory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "memory", r.memory, "")
	}
	if r.unit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unit", r.unit, "")
	}
	if r.flavor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flavor", r.flavor, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.softwarePkg != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "softwarePkg", r.softwarePkg, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetrosUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SetupApiService
	authorization *string
	region        *string
	offset        *string
	limit         *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetMetrosUsingGETRequest) Authorization(authorization string) ApiGetMetrosUsingGETRequest {
	r.authorization = &authorization
	return r
}

// Name of the region for which you want metros (e.g., AMER)
func (r ApiGetMetrosUsingGETRequest) Region(region string) ApiGetMetrosUsingGETRequest {
	r.region = &region
	return r
}

// Specifies where to start a page. It is the starting point of the collection returned from the server.
func (r ApiGetMetrosUsingGETRequest) Offset(offset string) ApiGetMetrosUsingGETRequest {
	r.offset = &offset
	return r
}

// Specifies the page size.
func (r ApiGetMetrosUsingGETRequest) Limit(limit string) ApiGetMetrosUsingGETRequest {
	r.limit = &limit
	return r
}

func (r ApiGetMetrosUsingGETRequest) Execute() (*PageResponseDtoMetroResponse, *http.Response, error) {
	return r.ApiService.GetMetrosUsingGETExecute(r)
}

/*
GetMetrosUsingGET Get Available Metros

Gets the available list of metros where NE platform is available. Please note that an account must be created for each country where virtual devices are being purchased.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMetrosUsingGETRequest
*/
func (a *SetupApiService) GetMetrosUsingGET(ctx context.Context) ApiGetMetrosUsingGETRequest {
	return ApiGetMetrosUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PageResponseDtoMetroResponse
func (a *SetupApiService) GetMetrosUsingGETExecute(r ApiGetMetrosUsingGETRequest) (*PageResponseDtoMetroResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageResponseDtoMetroResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetMetrosUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/metros"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue string = "0"
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue string = "20"
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotificationsUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SetupApiService
	authorization *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetNotificationsUsingGETRequest) Authorization(authorization string) ApiGetNotificationsUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetNotificationsUsingGETRequest) Execute() (*DowntimeNotification, *http.Response, error) {
	return r.ApiService.GetNotificationsUsingGETExecute(r)
}

/*
GetNotificationsUsingGET Get Downtime Notifications

Returns all planned and unplanned downtime notifications related to APIs and infrastructure. Please pass a token in the header.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetNotificationsUsingGETRequest
*/
func (a *SetupApiService) GetNotificationsUsingGET(ctx context.Context) ApiGetNotificationsUsingGETRequest {
	return ApiGetNotificationsUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DowntimeNotification
func (a *SetupApiService) GetNotificationsUsingGETExecute(r ApiGetNotificationsUsingGETRequest) (*DowntimeNotification, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DowntimeNotification
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetNotificationsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/notifications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderSummaryUsingGETRequest struct {
	ctx                          context.Context
	ApiService                   *SetupApiService
	authorization                *string
	accountNumber                *int32
	metro                        *string
	vendorPackage                *string
	licenseType                  *string
	softwarePackage              *string
	throughput                   *int32
	throughputUnit               *string
	termLength                   *string
	additionalBandwidth          *int32
	virtualDeviceUuid            *string
	deviceManagementType         *string
	core                         *int32
	secondaryAccountNumber       *int32
	secondaryMetro               *string
	secondaryAdditionalBandwidth *int32
	accountUcmId                 *string
	orderingContact              *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetOrderSummaryUsingGETRequest) Authorization(authorization string) ApiGetOrderSummaryUsingGETRequest {
	r.authorization = &authorization
	return r
}

// Account number
func (r ApiGetOrderSummaryUsingGETRequest) AccountNumber(accountNumber int32) ApiGetOrderSummaryUsingGETRequest {
	r.accountNumber = &accountNumber
	return r
}

// Metro
func (r ApiGetOrderSummaryUsingGETRequest) Metro(metro string) ApiGetOrderSummaryUsingGETRequest {
	r.metro = &metro
	return r
}

// Vendor package
func (r ApiGetOrderSummaryUsingGETRequest) VendorPackage(vendorPackage string) ApiGetOrderSummaryUsingGETRequest {
	r.vendorPackage = &vendorPackage
	return r
}

// License type
func (r ApiGetOrderSummaryUsingGETRequest) LicenseType(licenseType string) ApiGetOrderSummaryUsingGETRequest {
	r.licenseType = &licenseType
	return r
}

// Software package
func (r ApiGetOrderSummaryUsingGETRequest) SoftwarePackage(softwarePackage string) ApiGetOrderSummaryUsingGETRequest {
	r.softwarePackage = &softwarePackage
	return r
}

// Throughput
func (r ApiGetOrderSummaryUsingGETRequest) Throughput(throughput int32) ApiGetOrderSummaryUsingGETRequest {
	r.throughput = &throughput
	return r
}

// Throughput unit
func (r ApiGetOrderSummaryUsingGETRequest) ThroughputUnit(throughputUnit string) ApiGetOrderSummaryUsingGETRequest {
	r.throughputUnit = &throughputUnit
	return r
}

// Term length (in months)
func (r ApiGetOrderSummaryUsingGETRequest) TermLength(termLength string) ApiGetOrderSummaryUsingGETRequest {
	r.termLength = &termLength
	return r
}

// Additional bandwidth (in Mbps)
func (r ApiGetOrderSummaryUsingGETRequest) AdditionalBandwidth(additionalBandwidth int32) ApiGetOrderSummaryUsingGETRequest {
	r.additionalBandwidth = &additionalBandwidth
	return r
}

// Virtual device unique Id (only required if existing device is being modified)
func (r ApiGetOrderSummaryUsingGETRequest) VirtualDeviceUuid(virtualDeviceUuid string) ApiGetOrderSummaryUsingGETRequest {
	r.virtualDeviceUuid = &virtualDeviceUuid
	return r
}

// The device management type
func (r ApiGetOrderSummaryUsingGETRequest) DeviceManagementType(deviceManagementType string) ApiGetOrderSummaryUsingGETRequest {
	r.deviceManagementType = &deviceManagementType
	return r
}

// The number of cores
func (r ApiGetOrderSummaryUsingGETRequest) Core(core int32) ApiGetOrderSummaryUsingGETRequest {
	r.core = &core
	return r
}

// Secondary account number (in case you have a device pair)
func (r ApiGetOrderSummaryUsingGETRequest) SecondaryAccountNumber(secondaryAccountNumber int32) ApiGetOrderSummaryUsingGETRequest {
	r.secondaryAccountNumber = &secondaryAccountNumber
	return r
}

// Secondary metro (in case you have a device pair)
func (r ApiGetOrderSummaryUsingGETRequest) SecondaryMetro(secondaryMetro string) ApiGetOrderSummaryUsingGETRequest {
	r.secondaryMetro = &secondaryMetro
	return r
}

// Secondary additional bandwidth (in Mbps)
func (r ApiGetOrderSummaryUsingGETRequest) SecondaryAdditionalBandwidth(secondaryAdditionalBandwidth int32) ApiGetOrderSummaryUsingGETRequest {
	r.secondaryAdditionalBandwidth = &secondaryAdditionalBandwidth
	return r
}

// Account unique ID
func (r ApiGetOrderSummaryUsingGETRequest) AccountUcmId(accountUcmId string) ApiGetOrderSummaryUsingGETRequest {
	r.accountUcmId = &accountUcmId
	return r
}

// Reseller customer username
func (r ApiGetOrderSummaryUsingGETRequest) OrderingContact(orderingContact string) ApiGetOrderSummaryUsingGETRequest {
	r.orderingContact = &orderingContact
	return r
}

func (r ApiGetOrderSummaryUsingGETRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetOrderSummaryUsingGETExecute(r)
}

/*
GetOrderSummaryUsingGET Get Order Summary

Gets the order summary as a printable pdf file. This API helps customers who have to go through a PO process at their end to make a purchase and need a formal quote

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetOrderSummaryUsingGETRequest
*/
func (a *SetupApiService) GetOrderSummaryUsingGET(ctx context.Context) ApiGetOrderSummaryUsingGETRequest {
	return ApiGetOrderSummaryUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SetupApiService) GetOrderSummaryUsingGETExecute(r ApiGetOrderSummaryUsingGETRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetOrderSummaryUsingGET")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/orderSummaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	if r.accountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNumber", r.accountNumber, "")
	}
	if r.metro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metro", r.metro, "")
	}
	if r.vendorPackage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorPackage", r.vendorPackage, "")
	}
	if r.licenseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "licenseType", r.licenseType, "")
	}
	if r.softwarePackage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "softwarePackage", r.softwarePackage, "")
	}
	if r.throughput != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "throughput", r.throughput, "")
	}
	if r.throughputUnit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "throughputUnit", r.throughputUnit, "")
	}
	if r.termLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "termLength", r.termLength, "")
	}
	if r.additionalBandwidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additionalBandwidth", r.additionalBandwidth, "")
	}
	if r.virtualDeviceUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualDeviceUuid", r.virtualDeviceUuid, "")
	}
	if r.deviceManagementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceManagementType", r.deviceManagementType, "")
	}
	if r.core != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core", r.core, "")
	}
	if r.secondaryAccountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondaryAccountNumber", r.secondaryAccountNumber, "")
	}
	if r.secondaryMetro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondaryMetro", r.secondaryMetro, "")
	}
	if r.secondaryAdditionalBandwidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondaryAdditionalBandwidth", r.secondaryAdditionalBandwidth, "")
	}
	if r.accountUcmId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountUcmId", r.accountUcmId, "")
	}
	if r.orderingContact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderingContact", r.orderingContact, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetOrderTermsUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SetupApiService
	authorization *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetOrderTermsUsingGETRequest) Authorization(authorization string) ApiGetOrderTermsUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetOrderTermsUsingGETRequest) Execute() (*OrderTermsResponse, *http.Response, error) {
	return r.ApiService.GetOrderTermsUsingGETExecute(r)
}

/*
GetOrderTermsUsingGET Get Order Terms

Retrieves the terms and conditions of orders. Please read the terms and conditions before placing an order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetOrderTermsUsingGETRequest
*/
func (a *SetupApiService) GetOrderTermsUsingGET(ctx context.Context) ApiGetOrderTermsUsingGETRequest {
	return ApiGetOrderTermsUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OrderTermsResponse
func (a *SetupApiService) GetOrderTermsUsingGETExecute(r ApiGetOrderTermsUsingGETRequest) (*OrderTermsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrderTermsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetOrderTermsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/agreements/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicKeysUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SetupApiService
	authorization *string
	accountUcmId  *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetPublicKeysUsingGETRequest) Authorization(authorization string) ApiGetPublicKeysUsingGETRequest {
	r.authorization = &authorization
	return r
}

// This field is for resellers. Please pass the accountUcmId of your customer to get the public keys.
func (r ApiGetPublicKeysUsingGETRequest) AccountUcmId(accountUcmId string) ApiGetPublicKeysUsingGETRequest {
	r.accountUcmId = &accountUcmId
	return r
}

func (r ApiGetPublicKeysUsingGETRequest) Execute() ([]PageResponsePublicKeys, *http.Response, error) {
	return r.ApiService.GetPublicKeysUsingGETExecute(r)
}

/*
GetPublicKeysUsingGET Get Public Keys

Returns the SSH public keys associated with this organization. If you are a reseller, please pass the account number of you customer to get the public keys.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPublicKeysUsingGETRequest
*/
func (a *SetupApiService) GetPublicKeysUsingGET(ctx context.Context) ApiGetPublicKeysUsingGETRequest {
	return ApiGetPublicKeysUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []PageResponsePublicKeys
func (a *SetupApiService) GetPublicKeysUsingGETExecute(r ApiGetPublicKeysUsingGETRequest) ([]PageResponsePublicKeys, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []PageResponsePublicKeys
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetPublicKeysUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/publicKeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.accountUcmId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountUcmId", r.accountUcmId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVendorTermsUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SetupApiService
	vendorPackage *string
	licenseType   *string
	authorization *string
}

// vendorPackage
func (r ApiGetVendorTermsUsingGETRequest) VendorPackage(vendorPackage string) ApiGetVendorTermsUsingGETRequest {
	r.vendorPackage = &vendorPackage
	return r
}

// licenseType
func (r ApiGetVendorTermsUsingGETRequest) LicenseType(licenseType string) ApiGetVendorTermsUsingGETRequest {
	r.licenseType = &licenseType
	return r
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetVendorTermsUsingGETRequest) Authorization(authorization string) ApiGetVendorTermsUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetVendorTermsUsingGETRequest) Execute() (*VendorTermsResponse, *http.Response, error) {
	return r.ApiService.GetVendorTermsUsingGETExecute(r)
}

/*
GetVendorTermsUsingGET Get Vendor Terms

Returns a link to a vendor's terms. The term "vendor" refers to the vendor of a virtual device on the Network Edge platform.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetVendorTermsUsingGETRequest
*/
func (a *SetupApiService) GetVendorTermsUsingGET(ctx context.Context) ApiGetVendorTermsUsingGETRequest {
	return ApiGetVendorTermsUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VendorTermsResponse
func (a *SetupApiService) GetVendorTermsUsingGETExecute(r ApiGetVendorTermsUsingGETRequest) (*VendorTermsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VendorTermsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetVendorTermsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/agreements/vendors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vendorPackage == nil {
		return localVarReturnValue, nil, reportError("vendorPackage is required and must be specified")
	}
	if r.licenseType == nil {
		return localVarReturnValue, nil, reportError("licenseType is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "vendorPackage", r.vendorPackage, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "licenseType", r.licenseType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVirtualDevicesUsingGETRequest struct {
	ctx            context.Context
	ApiService     *SetupApiService
	authorization  *string
	deviceTypeCode *string
	category       *string
	offset         *string
	limit          *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetVirtualDevicesUsingGETRequest) Authorization(authorization string) ApiGetVirtualDevicesUsingGETRequest {
	r.authorization = &authorization
	return r
}

// Device type code (e.g., C8000V)
func (r ApiGetVirtualDevicesUsingGETRequest) DeviceTypeCode(deviceTypeCode string) ApiGetVirtualDevicesUsingGETRequest {
	r.deviceTypeCode = &deviceTypeCode
	return r
}

// Category. One of FIREWALL, ROUTER or SD-WAN
func (r ApiGetVirtualDevicesUsingGETRequest) Category(category string) ApiGetVirtualDevicesUsingGETRequest {
	r.category = &category
	return r
}

// Specifies where to start a page. It is the starting point of the collection returned from the server.
func (r ApiGetVirtualDevicesUsingGETRequest) Offset(offset string) ApiGetVirtualDevicesUsingGETRequest {
	r.offset = &offset
	return r
}

// Specifies the page size.
func (r ApiGetVirtualDevicesUsingGETRequest) Limit(limit string) ApiGetVirtualDevicesUsingGETRequest {
	r.limit = &limit
	return r
}

func (r ApiGetVirtualDevicesUsingGETRequest) Execute() (*PageResponseDtoVirtualDeviceType, *http.Response, error) {
	return r.ApiService.GetVirtualDevicesUsingGETExecute(r)
}

/*
GetVirtualDevicesUsingGET Get Device Types

Returns device types (e.g., routers and firewalls) that can be launched on the NE platform.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetVirtualDevicesUsingGETRequest
*/
func (a *SetupApiService) GetVirtualDevicesUsingGET(ctx context.Context) ApiGetVirtualDevicesUsingGETRequest {
	return ApiGetVirtualDevicesUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PageResponseDtoVirtualDeviceType
func (a *SetupApiService) GetVirtualDevicesUsingGETExecute(r ApiGetVirtualDevicesUsingGETRequest) (*PageResponseDtoVirtualDeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageResponseDtoVirtualDeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.GetVirtualDevicesUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/deviceTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceTypeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypeCode", r.deviceTypeCode, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue string = "0"
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue string = "20"
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPublicKeyUsingPOSTRequest struct {
	ctx              context.Context
	ApiService       *SetupApiService
	authorization    *string
	publicKeyRequest *PublicKeyRequest
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiPostPublicKeyUsingPOSTRequest) Authorization(authorization string) ApiPostPublicKeyUsingPOSTRequest {
	r.authorization = &authorization
	return r
}

// keyName, keyValue, and keyType
func (r ApiPostPublicKeyUsingPOSTRequest) PublicKeyRequest(publicKeyRequest PublicKeyRequest) ApiPostPublicKeyUsingPOSTRequest {
	r.publicKeyRequest = &publicKeyRequest
	return r
}

func (r ApiPostPublicKeyUsingPOSTRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPublicKeyUsingPOSTExecute(r)
}

/*
PostPublicKeyUsingPOST Create Public Key

Creates a public key. If you are a reseller, pass the account number of your customer to create a key-name and key-value pair.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPublicKeyUsingPOSTRequest
*/
func (a *SetupApiService) PostPublicKeyUsingPOST(ctx context.Context) ApiPostPublicKeyUsingPOSTRequest {
	return ApiPostPublicKeyUsingPOSTRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SetupApiService) PostPublicKeyUsingPOSTExecute(r ApiPostPublicKeyUsingPOSTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.PostPublicKeyUsingPOST")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/publicKeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.publicKeyRequest == nil {
		return nil, reportError("publicKeyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.publicKeyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRetrievePriceUsingGETRequest struct {
	ctx                          context.Context
	ApiService                   *SetupApiService
	authorization                *string
	accountNumber                *int32
	metro                        *string
	vendorPackage                *string
	licenseType                  *string
	softwarePackage              *string
	throughput                   *int32
	throughputUnit               *string
	termLength                   *string
	additionalBandwidth          *int32
	virtualDeviceUuid            *string
	deviceManagementType         *string
	core                         *int32
	secondaryAccountNumber       *int32
	secondaryMetro               *string
	secondaryAdditionalBandwidth *int32
	accountUcmId                 *string
	orderingContact              *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiRetrievePriceUsingGETRequest) Authorization(authorization string) ApiRetrievePriceUsingGETRequest {
	r.authorization = &authorization
	return r
}

// Account number
func (r ApiRetrievePriceUsingGETRequest) AccountNumber(accountNumber int32) ApiRetrievePriceUsingGETRequest {
	r.accountNumber = &accountNumber
	return r
}

// Metro
func (r ApiRetrievePriceUsingGETRequest) Metro(metro string) ApiRetrievePriceUsingGETRequest {
	r.metro = &metro
	return r
}

// Vendor package
func (r ApiRetrievePriceUsingGETRequest) VendorPackage(vendorPackage string) ApiRetrievePriceUsingGETRequest {
	r.vendorPackage = &vendorPackage
	return r
}

// License type
func (r ApiRetrievePriceUsingGETRequest) LicenseType(licenseType string) ApiRetrievePriceUsingGETRequest {
	r.licenseType = &licenseType
	return r
}

// Software package
func (r ApiRetrievePriceUsingGETRequest) SoftwarePackage(softwarePackage string) ApiRetrievePriceUsingGETRequest {
	r.softwarePackage = &softwarePackage
	return r
}

// Throughput
func (r ApiRetrievePriceUsingGETRequest) Throughput(throughput int32) ApiRetrievePriceUsingGETRequest {
	r.throughput = &throughput
	return r
}

// Throughput unit
func (r ApiRetrievePriceUsingGETRequest) ThroughputUnit(throughputUnit string) ApiRetrievePriceUsingGETRequest {
	r.throughputUnit = &throughputUnit
	return r
}

// Term length (in months)
func (r ApiRetrievePriceUsingGETRequest) TermLength(termLength string) ApiRetrievePriceUsingGETRequest {
	r.termLength = &termLength
	return r
}

// Additional bandwidth (in Mbps)
func (r ApiRetrievePriceUsingGETRequest) AdditionalBandwidth(additionalBandwidth int32) ApiRetrievePriceUsingGETRequest {
	r.additionalBandwidth = &additionalBandwidth
	return r
}

// Virtual device unique Id (only required if existing device is being modified)
func (r ApiRetrievePriceUsingGETRequest) VirtualDeviceUuid(virtualDeviceUuid string) ApiRetrievePriceUsingGETRequest {
	r.virtualDeviceUuid = &virtualDeviceUuid
	return r
}

// The device management type
func (r ApiRetrievePriceUsingGETRequest) DeviceManagementType(deviceManagementType string) ApiRetrievePriceUsingGETRequest {
	r.deviceManagementType = &deviceManagementType
	return r
}

// The number of cores
func (r ApiRetrievePriceUsingGETRequest) Core(core int32) ApiRetrievePriceUsingGETRequest {
	r.core = &core
	return r
}

// The secondary account number (for HA)
func (r ApiRetrievePriceUsingGETRequest) SecondaryAccountNumber(secondaryAccountNumber int32) ApiRetrievePriceUsingGETRequest {
	r.secondaryAccountNumber = &secondaryAccountNumber
	return r
}

// Secondary metro (for HA)
func (r ApiRetrievePriceUsingGETRequest) SecondaryMetro(secondaryMetro string) ApiRetrievePriceUsingGETRequest {
	r.secondaryMetro = &secondaryMetro
	return r
}

// Secondary additional bandwidth (in Mbps for HA)
func (r ApiRetrievePriceUsingGETRequest) SecondaryAdditionalBandwidth(secondaryAdditionalBandwidth int32) ApiRetrievePriceUsingGETRequest {
	r.secondaryAdditionalBandwidth = &secondaryAdditionalBandwidth
	return r
}

// Account unique ID
func (r ApiRetrievePriceUsingGETRequest) AccountUcmId(accountUcmId string) ApiRetrievePriceUsingGETRequest {
	r.accountUcmId = &accountUcmId
	return r
}

// Reseller customer username
func (r ApiRetrievePriceUsingGETRequest) OrderingContact(orderingContact string) ApiRetrievePriceUsingGETRequest {
	r.orderingContact = &orderingContact
	return r
}

func (r ApiRetrievePriceUsingGETRequest) Execute() (*CompositePriceResponse, *http.Response, error) {
	return r.ApiService.RetrievePriceUsingGETExecute(r)
}

/*
RetrievePriceUsingGET Get the Price

Returns the price of a virtual device and license based on account number and other fields. Please note that the listed price does not include the price of any optional features added to the device, some of which are charged.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRetrievePriceUsingGETRequest
*/
func (a *SetupApiService) RetrievePriceUsingGET(ctx context.Context) ApiRetrievePriceUsingGETRequest {
	return ApiRetrievePriceUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CompositePriceResponse
func (a *SetupApiService) RetrievePriceUsingGETExecute(r ApiRetrievePriceUsingGETRequest) (*CompositePriceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompositePriceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.RetrievePriceUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/prices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.accountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNumber", r.accountNumber, "")
	}
	if r.metro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metro", r.metro, "")
	}
	if r.vendorPackage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorPackage", r.vendorPackage, "")
	}
	if r.licenseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "licenseType", r.licenseType, "")
	}
	if r.softwarePackage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "softwarePackage", r.softwarePackage, "")
	}
	if r.throughput != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "throughput", r.throughput, "")
	}
	if r.throughputUnit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "throughputUnit", r.throughputUnit, "")
	}
	if r.termLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "termLength", r.termLength, "")
	}
	if r.additionalBandwidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additionalBandwidth", r.additionalBandwidth, "")
	}
	if r.virtualDeviceUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualDeviceUuid", r.virtualDeviceUuid, "")
	}
	if r.deviceManagementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceManagementType", r.deviceManagementType, "")
	}
	if r.core != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "core", r.core, "")
	}
	if r.secondaryAccountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondaryAccountNumber", r.secondaryAccountNumber, "")
	}
	if r.secondaryMetro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondaryMetro", r.secondaryMetro, "")
	}
	if r.secondaryAdditionalBandwidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondaryAdditionalBandwidth", r.secondaryAdditionalBandwidth, "")
	}
	if r.accountUcmId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountUcmId", r.accountUcmId, "")
	}
	if r.orderingContact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderingContact", r.orderingContact, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendAgreementUsingPOST1Request struct {
	ctx                    context.Context
	ApiService             *SetupApiService
	authorization          *string
	agreementAcceptRequest *AgreementAcceptRequest
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiSendAgreementUsingPOST1Request) Authorization(authorization string) ApiSendAgreementUsingPOST1Request {
	r.authorization = &authorization
	return r
}

// agreementAcceptRequest
func (r ApiSendAgreementUsingPOST1Request) AgreementAcceptRequest(agreementAcceptRequest AgreementAcceptRequest) ApiSendAgreementUsingPOST1Request {
	r.agreementAcceptRequest = &agreementAcceptRequest
	return r
}

func (r ApiSendAgreementUsingPOST1Request) Execute() (*AgreementAcceptResponse, *http.Response, error) {
	return r.ApiService.SendAgreementUsingPOST1Execute(r)
}

/*
SendAgreementUsingPOST1 Create an agreement

Call this API to post an agreement. The authorization token and content-type are the only headers that are passed to this API and a response is received based on the values passed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendAgreementUsingPOST1Request
*/
func (a *SetupApiService) SendAgreementUsingPOST1(ctx context.Context) ApiSendAgreementUsingPOST1Request {
	return ApiSendAgreementUsingPOST1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgreementAcceptResponse
func (a *SetupApiService) SendAgreementUsingPOST1Execute(r ApiSendAgreementUsingPOST1Request) (*AgreementAcceptResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgreementAcceptResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.SendAgreementUsingPOST1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/agreements/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.agreementAcceptRequest == nil {
		return localVarReturnValue, nil, reportError("agreementAcceptRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.agreementAcceptRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileUsingPOSTRequest struct {
	ctx                  context.Context
	ApiService           *SetupApiService
	authorization        *string
	file                 *os.File
	metroCode            *string
	deviceTypeCode       *string
	processType          *string
	deviceManagementType *string
	licenseType          *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiUploadFileUsingPOSTRequest) Authorization(authorization string) ApiUploadFileUsingPOSTRequest {
	r.authorization = &authorization
	return r
}

// A license or a cloud_init file. For example, for Aviatrix, this is your bootsrap config file generated from the Aviatrix Controller portal.
func (r ApiUploadFileUsingPOSTRequest) File(file *os.File) ApiUploadFileUsingPOSTRequest {
	r.file = file
	return r
}

// Two-letter metro code.
func (r ApiUploadFileUsingPOSTRequest) MetroCode(metroCode string) ApiUploadFileUsingPOSTRequest {
	r.metroCode = &metroCode
	return r
}

// Device type code, e.g., AVIATRIX_EDGE
func (r ApiUploadFileUsingPOSTRequest) DeviceTypeCode(deviceTypeCode string) ApiUploadFileUsingPOSTRequest {
	r.deviceTypeCode = &deviceTypeCode
	return r
}

// Whether you are uploading a license or a cloud_init file. LICENSE or CLOUD_INIT
func (r ApiUploadFileUsingPOSTRequest) ProcessType(processType string) ApiUploadFileUsingPOSTRequest {
	r.processType = &processType
	return r
}

// Device management type, whether SELF-CONFIGURED or not
func (r ApiUploadFileUsingPOSTRequest) DeviceManagementType(deviceManagementType string) ApiUploadFileUsingPOSTRequest {
	r.deviceManagementType = &deviceManagementType
	return r
}

// Type of license (BYOL-Bring Your Own License)
func (r ApiUploadFileUsingPOSTRequest) LicenseType(licenseType string) ApiUploadFileUsingPOSTRequest {
	r.licenseType = &licenseType
	return r
}

func (r ApiUploadFileUsingPOSTRequest) Execute() (*FileUploadResponse, *http.Response, error) {
	return r.ApiService.UploadFileUsingPOSTExecute(r)
}

/*
UploadFileUsingPOST Upload File (Post)

Uploads a license or an initialization file. You can use this API to upload your bootstrap file generated from the Aviatrix controller portal. The response includes the unique ID of the uploaded file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUploadFileUsingPOSTRequest
*/
func (a *SetupApiService) UploadFileUsingPOST(ctx context.Context) ApiUploadFileUsingPOSTRequest {
	return ApiUploadFileUsingPOSTRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FileUploadResponse
func (a *SetupApiService) UploadFileUsingPOSTExecute(r ApiUploadFileUsingPOSTRequest) (*FileUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FileUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetupApiService.UploadFileUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}
	if r.metroCode == nil {
		return localVarReturnValue, nil, reportError("metroCode is required and must be specified")
	}
	if r.deviceTypeCode == nil {
		return localVarReturnValue, nil, reportError("deviceTypeCode is required and must be specified")
	}
	if r.processType == nil {
		return localVarReturnValue, nil, reportError("processType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.deviceManagementType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deviceManagementType", r.deviceManagementType, "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.licenseType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "licenseType", r.licenseType, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "metroCode", r.metroCode, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "deviceTypeCode", r.deviceTypeCode, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "processType", r.processType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
