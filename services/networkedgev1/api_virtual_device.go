/*
Network Edge APIs

Network Edge (NE) is a platform that allows customers to deploy and run virtual network services and appliances such as routers, load balancers, and firewalls on a generic device instead of additional dedicated hardware, CapEx and colo space. The Network Edge REST APIs allow you to interact with the Equinix Platform to programmatically create a virtual device and add services. Details on specific use cases can be found in the documentation available on the developer portal.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package networkedgev1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// VirtualDeviceApiService VirtualDeviceApi service
type VirtualDeviceApiService service

type ApiCreateVirtualDeviceUsingPOSTRequest struct {
	ctx           context.Context
	ApiService    *VirtualDeviceApiService
	authorization *string
	virtualDevice *VirtualDeviceRequest
	draft         *bool
	draftUuid     *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiCreateVirtualDeviceUsingPOSTRequest) Authorization(authorization string) ApiCreateVirtualDeviceUsingPOSTRequest {
	r.authorization = &authorization
	return r
}

// Create a virtual device (e.g., a router or a firewall)
func (r ApiCreateVirtualDeviceUsingPOSTRequest) VirtualDevice(virtualDevice VirtualDeviceRequest) ApiCreateVirtualDeviceUsingPOSTRequest {
	r.virtualDevice = &virtualDevice
	return r
}

// draft
func (r ApiCreateVirtualDeviceUsingPOSTRequest) Draft(draft bool) ApiCreateVirtualDeviceUsingPOSTRequest {
	r.draft = &draft
	return r
}

// draftUuid
func (r ApiCreateVirtualDeviceUsingPOSTRequest) DraftUuid(draftUuid string) ApiCreateVirtualDeviceUsingPOSTRequest {
	r.draftUuid = &draftUuid
	return r
}

func (r ApiCreateVirtualDeviceUsingPOSTRequest) Execute() (*VirtualDeviceCreateResponse, *http.Response, error) {
	return r.ApiService.CreateVirtualDeviceUsingPOSTExecute(r)
}

/*
CreateVirtualDeviceUsingPOST Create Virtual Device

Creates a virtual device. Sub-customers cannot choose the subscription licensing option. To create a device, you must accept the Order Terms. Call Get Order Terms to review the details. If you are creating an Equinix-Configured device, read your vendor's terms by calling Get Vendor Terms.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateVirtualDeviceUsingPOSTRequest
*/
func (a *VirtualDeviceApiService) CreateVirtualDeviceUsingPOST(ctx context.Context) ApiCreateVirtualDeviceUsingPOSTRequest {
	return ApiCreateVirtualDeviceUsingPOSTRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VirtualDeviceCreateResponse
func (a *VirtualDeviceApiService) CreateVirtualDeviceUsingPOSTExecute(r ApiCreateVirtualDeviceUsingPOSTRequest) (*VirtualDeviceCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VirtualDeviceCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.CreateVirtualDeviceUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.virtualDevice == nil {
		return localVarReturnValue, nil, reportError("virtualDevice is required and must be specified")
	}

	if r.draft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "draft", r.draft, "")
	} else {
		var defaultValue bool = false
		r.draft = &defaultValue
	}
	if r.draftUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "draftUuid", r.draftUuid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.virtualDevice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVRouterUsingDELETERequest struct {
	ctx                   context.Context
	ApiService            *VirtualDeviceApiService
	uuid                  string
	authorization         *string
	deleteRedundantDevice *bool
	deletionInfo          *VirtualDeviceDeleteRequest
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiDeleteVRouterUsingDELETERequest) Authorization(authorization string) ApiDeleteVRouterUsingDELETERequest {
	r.authorization = &authorization
	return r
}

// Optional parameter in case you have a secondary device. As both primary and secondary devices are deleted simultaneously, this field must be marked True so we delete both the devices simultaneously.
func (r ApiDeleteVRouterUsingDELETERequest) DeleteRedundantDevice(deleteRedundantDevice bool) ApiDeleteVRouterUsingDELETERequest {
	r.deleteRedundantDevice = &deleteRedundantDevice
	return r
}

// deletionInfo
func (r ApiDeleteVRouterUsingDELETERequest) DeletionInfo(deletionInfo VirtualDeviceDeleteRequest) ApiDeleteVRouterUsingDELETERequest {
	r.deletionInfo = &deletionInfo
	return r
}

func (r ApiDeleteVRouterUsingDELETERequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVRouterUsingDELETEExecute(r)
}

/*
DeleteVRouterUsingDELETE Delete Virtual Devices

Delete a virtual device. For some device types (e.g., Palo Alto devices), you also need to provide a deactivation key as a body parameter. For a device pair, the deleteRedundantDevice field must be marked True so we delete both the devices simultaneously.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid Unique Id of the virtual device.
	@return ApiDeleteVRouterUsingDELETERequest
*/
func (a *VirtualDeviceApiService) DeleteVRouterUsingDELETE(ctx context.Context, uuid string) ApiDeleteVRouterUsingDELETERequest {
	return ApiDeleteVRouterUsingDELETERequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
func (a *VirtualDeviceApiService) DeleteVRouterUsingDELETEExecute(r ApiDeleteVRouterUsingDELETERequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.DeleteVRouterUsingDELETE")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	if r.deleteRedundantDevice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteRedundantDevice", r.deleteRedundantDevice, "")
	} else {
		var defaultValue bool = false
		r.deleteRedundantDevice = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.deletionInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeviceReloadUsingGET1Request struct {
	ctx               context.Context
	ApiService        *VirtualDeviceApiService
	virtualDeviceUUID string
	authorization     *string
	offset            *string
	limit             *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetDeviceReloadUsingGET1Request) Authorization(authorization string) ApiGetDeviceReloadUsingGET1Request {
	r.authorization = &authorization
	return r
}

// Specifies where to start a page. It is the starting point of the collection returned from the server.
func (r ApiGetDeviceReloadUsingGET1Request) Offset(offset string) ApiGetDeviceReloadUsingGET1Request {
	r.offset = &offset
	return r
}

// Specifies the page size.
func (r ApiGetDeviceReloadUsingGET1Request) Limit(limit string) ApiGetDeviceReloadUsingGET1Request {
	r.limit = &limit
	return r
}

func (r ApiGetDeviceReloadUsingGET1Request) Execute() (*DeviceRebootPageResponse, *http.Response, error) {
	return r.ApiService.GetDeviceReloadUsingGET1Execute(r)
}

/*
GetDeviceReloadUsingGET1 Device Reload History

Returns the reload history of a device. Please send the unique Id of the device as a path parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param virtualDeviceUUID Unique ID of a virtual device.
	@return ApiGetDeviceReloadUsingGET1Request
*/
func (a *VirtualDeviceApiService) GetDeviceReloadUsingGET1(ctx context.Context, virtualDeviceUUID string) ApiGetDeviceReloadUsingGET1Request {
	return ApiGetDeviceReloadUsingGET1Request{
		ApiService:        a,
		ctx:               ctx,
		virtualDeviceUUID: virtualDeviceUUID,
	}
}

// Execute executes the request
//
//	@return DeviceRebootPageResponse
func (a *VirtualDeviceApiService) GetDeviceReloadUsingGET1Execute(r ApiGetDeviceReloadUsingGET1Request) (*DeviceRebootPageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceRebootPageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.GetDeviceReloadUsingGET1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{virtualDeviceUUID}/softReboot"
	localVarPath = strings.Replace(localVarPath, "{"+"virtualDeviceUUID"+"}", url.PathEscape(parameterValueToString(r.virtualDeviceUUID, "virtualDeviceUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue string = "0"
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue string = "20"
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceUpgradeUsingGET1Request struct {
	ctx               context.Context
	ApiService        *VirtualDeviceApiService
	virtualDeviceUuid string
	authorization     *string
	offset            *string
	limit             *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetDeviceUpgradeUsingGET1Request) Authorization(authorization string) ApiGetDeviceUpgradeUsingGET1Request {
	r.authorization = &authorization
	return r
}

// Specifies where to start a page. It is the starting point of the collection returned from the server.
func (r ApiGetDeviceUpgradeUsingGET1Request) Offset(offset string) ApiGetDeviceUpgradeUsingGET1Request {
	r.offset = &offset
	return r
}

// Specifies the page size.
func (r ApiGetDeviceUpgradeUsingGET1Request) Limit(limit string) ApiGetDeviceUpgradeUsingGET1Request {
	r.limit = &limit
	return r
}

func (r ApiGetDeviceUpgradeUsingGET1Request) Execute() (*DeviceUpgradePageResponse, *http.Response, error) {
	return r.ApiService.GetDeviceUpgradeUsingGET1Execute(r)
}

/*
GetDeviceUpgradeUsingGET1 Get Device Upgrade History

Returns the upgrade history of a device. Please send the unique Id of the device as a path parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param virtualDeviceUuid Unique ID of a virtual device.
	@return ApiGetDeviceUpgradeUsingGET1Request
*/
func (a *VirtualDeviceApiService) GetDeviceUpgradeUsingGET1(ctx context.Context, virtualDeviceUuid string) ApiGetDeviceUpgradeUsingGET1Request {
	return ApiGetDeviceUpgradeUsingGET1Request{
		ApiService:        a,
		ctx:               ctx,
		virtualDeviceUuid: virtualDeviceUuid,
	}
}

// Execute executes the request
//
//	@return DeviceUpgradePageResponse
func (a *VirtualDeviceApiService) GetDeviceUpgradeUsingGET1Execute(r ApiGetDeviceUpgradeUsingGET1Request) (*DeviceUpgradePageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceUpgradePageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.GetDeviceUpgradeUsingGET1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{virtualDeviceUuid}/resourceUpgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"virtualDeviceUuid"+"}", url.PathEscape(parameterValueToString(r.virtualDeviceUuid, "virtualDeviceUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue string = "0"
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue string = "20"
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceStatisticsUsingGETRequest struct {
	ctx               context.Context
	ApiService        *VirtualDeviceApiService
	virtualDeviceUuid string
	interfaceId       string
	startDateTime     *string
	endDateTime       *string
	authorization     *string
}

// Start time of the duration for which you want stats. (YYYY-MM-DDThh:mm:ssZ)
func (r ApiGetInterfaceStatisticsUsingGETRequest) StartDateTime(startDateTime string) ApiGetInterfaceStatisticsUsingGETRequest {
	r.startDateTime = &startDateTime
	return r
}

// End time of the duration for which you want stats. (YYYY-MM-DDThh:mm:ssZ)
func (r ApiGetInterfaceStatisticsUsingGETRequest) EndDateTime(endDateTime string) ApiGetInterfaceStatisticsUsingGETRequest {
	r.endDateTime = &endDateTime
	return r
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetInterfaceStatisticsUsingGETRequest) Authorization(authorization string) ApiGetInterfaceStatisticsUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetInterfaceStatisticsUsingGETRequest) Execute() (*InterfaceStatsObject, *http.Response, error) {
	return r.ApiService.GetInterfaceStatisticsUsingGETExecute(r)
}

/*
GetInterfaceStatisticsUsingGET Get Interface Statistics

Returns the throughput statistics of a device interface. Pass the unique Id of the device and the interface Id as path parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param virtualDeviceUuid Unique Id of a device
	@param interfaceId Interface Id
	@return ApiGetInterfaceStatisticsUsingGETRequest
*/
func (a *VirtualDeviceApiService) GetInterfaceStatisticsUsingGET(ctx context.Context, virtualDeviceUuid string, interfaceId string) ApiGetInterfaceStatisticsUsingGETRequest {
	return ApiGetInterfaceStatisticsUsingGETRequest{
		ApiService:        a,
		ctx:               ctx,
		virtualDeviceUuid: virtualDeviceUuid,
		interfaceId:       interfaceId,
	}
}

// Execute executes the request
//
//	@return InterfaceStatsObject
func (a *VirtualDeviceApiService) GetInterfaceStatisticsUsingGETExecute(r ApiGetInterfaceStatisticsUsingGETRequest) (*InterfaceStatsObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InterfaceStatsObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.GetInterfaceStatisticsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{virtualDeviceUuid}/interfaces/{interfaceId}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"virtualDeviceUuid"+"}", url.PathEscape(parameterValueToString(r.virtualDeviceUuid, "virtualDeviceUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDateTime == nil {
		return localVarReturnValue, nil, reportError("startDateTime is required and must be specified")
	}
	if r.endDateTime == nil {
		return localVarReturnValue, nil, reportError("endDateTime is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDateTime", r.startDateTime, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDateTime", r.endDateTime, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVirtualDeviceInterfacesUsingGETRequest struct {
	ctx           context.Context
	ApiService    *VirtualDeviceApiService
	uuid          string
	authorization *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetVirtualDeviceInterfacesUsingGETRequest) Authorization(authorization string) ApiGetVirtualDeviceInterfacesUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetVirtualDeviceInterfacesUsingGETRequest) Execute() ([]InterfaceBasicInfoResponse, *http.Response, error) {
	return r.ApiService.GetVirtualDeviceInterfacesUsingGETExecute(r)
}

/*
GetVirtualDeviceInterfacesUsingGET Get Device Interfaces

Returns the status of the interfaces of a device. You must pass the unique Id of the device as a path parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid uuid
	@return ApiGetVirtualDeviceInterfacesUsingGETRequest
*/
func (a *VirtualDeviceApiService) GetVirtualDeviceInterfacesUsingGET(ctx context.Context, uuid string) ApiGetVirtualDeviceInterfacesUsingGETRequest {
	return ApiGetVirtualDeviceInterfacesUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
//
//	@return []InterfaceBasicInfoResponse
func (a *VirtualDeviceApiService) GetVirtualDeviceInterfacesUsingGETExecute(r ApiGetVirtualDeviceInterfacesUsingGETRequest) ([]InterfaceBasicInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []InterfaceBasicInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.GetVirtualDeviceInterfacesUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{uuid}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVirtualDeviceUsingGETRequest struct {
	ctx           context.Context
	ApiService    *VirtualDeviceApiService
	uuid          string
	authorization *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetVirtualDeviceUsingGETRequest) Authorization(authorization string) ApiGetVirtualDeviceUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetVirtualDeviceUsingGETRequest) Execute() (*VirtualDeviceDetailsResponse, *http.Response, error) {
	return r.ApiService.GetVirtualDeviceUsingGETExecute(r)
}

/*
GetVirtualDeviceUsingGET Get Virtual Device {uuid}

Returns the virtual device details of an existing device on the Network Edge platform. You must provide the unique ID of the existing device as a path parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid uuid
	@return ApiGetVirtualDeviceUsingGETRequest
*/
func (a *VirtualDeviceApiService) GetVirtualDeviceUsingGET(ctx context.Context, uuid string) ApiGetVirtualDeviceUsingGETRequest {
	return ApiGetVirtualDeviceUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
//
//	@return VirtualDeviceDetailsResponse
func (a *VirtualDeviceApiService) GetVirtualDeviceUsingGETExecute(r ApiGetVirtualDeviceUsingGETRequest) (*VirtualDeviceDetailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VirtualDeviceDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.GetVirtualDeviceUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVirtualDevicesUsingGET1Request struct {
	ctx                        context.Context
	ApiService                 *VirtualDeviceApiService
	authorization              *string
	offset                     *string
	limit                      *string
	metroCode                  *string
	status                     *string
	showOnlySubCustomerDevices *bool
	accountUcmId               *string
	searchText                 *string
	sort                       *[]string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetVirtualDevicesUsingGET1Request) Authorization(authorization string) ApiGetVirtualDevicesUsingGET1Request {
	r.authorization = &authorization
	return r
}

// Specifies where to start a page. It is the starting point of the collection returned from the server.
func (r ApiGetVirtualDevicesUsingGET1Request) Offset(offset string) ApiGetVirtualDevicesUsingGET1Request {
	r.offset = &offset
	return r
}

// Specifies the page size.
func (r ApiGetVirtualDevicesUsingGET1Request) Limit(limit string) ApiGetVirtualDevicesUsingGET1Request {
	r.limit = &limit
	return r
}

// metroCode
func (r ApiGetVirtualDevicesUsingGET1Request) MetroCode(metroCode string) ApiGetVirtualDevicesUsingGET1Request {
	r.metroCode = &metroCode
	return r
}

// status
func (r ApiGetVirtualDevicesUsingGET1Request) Status(status string) ApiGetVirtualDevicesUsingGET1Request {
	r.status = &status
	return r
}

// Resellers may mark this Yes to see sub customer devices.
func (r ApiGetVirtualDevicesUsingGET1Request) ShowOnlySubCustomerDevices(showOnlySubCustomerDevices bool) ApiGetVirtualDevicesUsingGET1Request {
	r.showOnlySubCustomerDevices = &showOnlySubCustomerDevices
	return r
}

// Unique ID of the account.
func (r ApiGetVirtualDevicesUsingGET1Request) AccountUcmId(accountUcmId string) ApiGetVirtualDevicesUsingGET1Request {
	r.accountUcmId = &accountUcmId
	return r
}

// Enter text to fetch only matching device names
func (r ApiGetVirtualDevicesUsingGET1Request) SearchText(searchText string) ApiGetVirtualDevicesUsingGET1Request {
	r.searchText = &searchText
	return r
}

// Sorts the output based on field names.
func (r ApiGetVirtualDevicesUsingGET1Request) Sort(sort []string) ApiGetVirtualDevicesUsingGET1Request {
	r.sort = &sort
	return r
}

func (r ApiGetVirtualDevicesUsingGET1Request) Execute() (*VirtualDevicePageResponse, *http.Response, error) {
	return r.ApiService.GetVirtualDevicesUsingGET1Execute(r)
}

/*
GetVirtualDevicesUsingGET1 Get Virtual Devices

Returns all the available virtual devices, i.e. routers and routers, on the Network Edge platform.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetVirtualDevicesUsingGET1Request
*/
func (a *VirtualDeviceApiService) GetVirtualDevicesUsingGET1(ctx context.Context) ApiGetVirtualDevicesUsingGET1Request {
	return ApiGetVirtualDevicesUsingGET1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VirtualDevicePageResponse
func (a *VirtualDeviceApiService) GetVirtualDevicesUsingGET1Execute(r ApiGetVirtualDevicesUsingGET1Request) (*VirtualDevicePageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VirtualDevicePageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.GetVirtualDevicesUsingGET1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue string = "0"
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue string = "20"
		r.limit = &defaultValue
	}
	if r.metroCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metroCode", r.metroCode, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.showOnlySubCustomerDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showOnlySubCustomerDevices", r.showOnlySubCustomerDevices, "")
	}
	if r.accountUcmId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountUcmId", r.accountUcmId, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingDeviceUsingGETRequest struct {
	ctx           context.Context
	ApiService    *VirtualDeviceApiService
	uuid          string
	authorization *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiPingDeviceUsingGETRequest) Authorization(authorization string) ApiPingDeviceUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiPingDeviceUsingGETRequest) Execute() (*http.Response, error) {
	return r.ApiService.PingDeviceUsingGETExecute(r)
}

/*
PingDeviceUsingGET Ping Virtual Device

Pings a virtual device to ensure it's reachable. At this point, you can only ping a few SELF-CONFIGURED devices.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid Virtual Device unique Id
	@return ApiPingDeviceUsingGETRequest
*/
func (a *VirtualDeviceApiService) PingDeviceUsingGET(ctx context.Context, uuid string) ApiPingDeviceUsingGETRequest {
	return ApiPingDeviceUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
func (a *VirtualDeviceApiService) PingDeviceUsingGETExecute(r ApiPingDeviceUsingGETRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.PingDeviceUsingGET")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{uuid}/ping"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostDeviceReloadUsingPOST1Request struct {
	ctx               context.Context
	ApiService        *VirtualDeviceApiService
	virtualDeviceUUID string
	authorization     *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiPostDeviceReloadUsingPOST1Request) Authorization(authorization string) ApiPostDeviceReloadUsingPOST1Request {
	r.authorization = &authorization
	return r
}

func (r ApiPostDeviceReloadUsingPOST1Request) Execute() (*http.Response, error) {
	return r.ApiService.PostDeviceReloadUsingPOST1Execute(r)
}

/*
PostDeviceReloadUsingPOST1 Trigger Soft Reboot

Triggers the soft reboot of a device. Please send the unique Id of the device as a path parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param virtualDeviceUUID Unique ID of a virtual device.
	@return ApiPostDeviceReloadUsingPOST1Request
*/
func (a *VirtualDeviceApiService) PostDeviceReloadUsingPOST1(ctx context.Context, virtualDeviceUUID string) ApiPostDeviceReloadUsingPOST1Request {
	return ApiPostDeviceReloadUsingPOST1Request{
		ApiService:        a,
		ctx:               ctx,
		virtualDeviceUUID: virtualDeviceUUID,
	}
}

// Execute executes the request
func (a *VirtualDeviceApiService) PostDeviceReloadUsingPOST1Execute(r ApiPostDeviceReloadUsingPOST1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.PostDeviceReloadUsingPOST1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{virtualDeviceUUID}/softReboot"
	localVarPath = strings.Replace(localVarPath, "{"+"virtualDeviceUUID"+"}", url.PathEscape(parameterValueToString(r.virtualDeviceUUID, "virtualDeviceUUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAdditionalBandwidthRequest struct {
	ctx           context.Context
	ApiService    *VirtualDeviceApiService
	uuid          string
	authorization *string
	request       *AdditionalBandwidthRequest
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiUpdateAdditionalBandwidthRequest) Authorization(authorization string) ApiUpdateAdditionalBandwidthRequest {
	r.authorization = &authorization
	return r
}

// Additional Bandwidth
func (r ApiUpdateAdditionalBandwidthRequest) Request(request AdditionalBandwidthRequest) ApiUpdateAdditionalBandwidthRequest {
	r.request = &request
	return r
}

func (r ApiUpdateAdditionalBandwidthRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAdditionalBandwidthExecute(r)
}

/*
UpdateAdditionalBandwidth Update Additional Bandwidth

You can use this method to change or add additional bandwidth to a virtual device.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The unique Id of a virtual device
	@return ApiUpdateAdditionalBandwidthRequest
*/
func (a *VirtualDeviceApiService) UpdateAdditionalBandwidth(ctx context.Context, uuid string) ApiUpdateAdditionalBandwidthRequest {
	return ApiUpdateAdditionalBandwidthRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
func (a *VirtualDeviceApiService) UpdateAdditionalBandwidthExecute(r ApiUpdateAdditionalBandwidthRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.UpdateAdditionalBandwidth")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{uuid}/additionalBandwidths"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateVirtualDeviceUsingPATCH1Request struct {
	ctx                           context.Context
	ApiService                    *VirtualDeviceApiService
	uuid                          string
	authorization                 *string
	virtualDeviceUpdateRequestDto *VirtualDeviceInternalPatchRequestDto
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiUpdateVirtualDeviceUsingPATCH1Request) Authorization(authorization string) ApiUpdateVirtualDeviceUsingPATCH1Request {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateVirtualDeviceUsingPATCH1Request) VirtualDeviceUpdateRequestDto(virtualDeviceUpdateRequestDto VirtualDeviceInternalPatchRequestDto) ApiUpdateVirtualDeviceUsingPATCH1Request {
	r.virtualDeviceUpdateRequestDto = &virtualDeviceUpdateRequestDto
	return r
}

func (r ApiUpdateVirtualDeviceUsingPATCH1Request) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVirtualDeviceUsingPATCH1Execute(r)
}

/*
UpdateVirtualDeviceUsingPATCH1 Update Virtual Device

Updates certain fields of a virtual device. You can only update the name, term length, status, and notification list of a virtual device.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The unique Id of the device.
	@return ApiUpdateVirtualDeviceUsingPATCH1Request
*/
func (a *VirtualDeviceApiService) UpdateVirtualDeviceUsingPATCH1(ctx context.Context, uuid string) ApiUpdateVirtualDeviceUsingPATCH1Request {
	return ApiUpdateVirtualDeviceUsingPATCH1Request{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
func (a *VirtualDeviceApiService) UpdateVirtualDeviceUsingPATCH1Execute(r ApiUpdateVirtualDeviceUsingPATCH1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.UpdateVirtualDeviceUsingPATCH1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.virtualDeviceUpdateRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateVirtualDeviceUsingPUTRequest struct {
	ctx           context.Context
	ApiService    *VirtualDeviceApiService
	draft         *bool
	uuid          string
	authorization *string
	virtualDevice *VirtualDeviceRequest
}

// draft
func (r ApiUpdateVirtualDeviceUsingPUTRequest) Draft(draft bool) ApiUpdateVirtualDeviceUsingPUTRequest {
	r.draft = &draft
	return r
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiUpdateVirtualDeviceUsingPUTRequest) Authorization(authorization string) ApiUpdateVirtualDeviceUsingPUTRequest {
	r.authorization = &authorization
	return r
}

// Update virtual device details
func (r ApiUpdateVirtualDeviceUsingPUTRequest) VirtualDevice(virtualDevice VirtualDeviceRequest) ApiUpdateVirtualDeviceUsingPUTRequest {
	r.virtualDevice = &virtualDevice
	return r
}

func (r ApiUpdateVirtualDeviceUsingPUTRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVirtualDeviceUsingPUTExecute(r)
}

/*
UpdateVirtualDeviceUsingPUT Update Device Draft

This API is for updating a virtual device draft <br/>and does not support device update as of now.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid Unique Id of a Virtual Device
	@return ApiUpdateVirtualDeviceUsingPUTRequest
*/
func (a *VirtualDeviceApiService) UpdateVirtualDeviceUsingPUT(ctx context.Context, uuid string) ApiUpdateVirtualDeviceUsingPUTRequest {
	return ApiUpdateVirtualDeviceUsingPUTRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
func (a *VirtualDeviceApiService) UpdateVirtualDeviceUsingPUTExecute(r ApiUpdateVirtualDeviceUsingPUTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirtualDeviceApiService.UpdateVirtualDeviceUsingPUT")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/devices/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.draft == nil {
		return nil, reportError("draft is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.virtualDevice == nil {
		return nil, reportError("virtualDevice is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "draft", r.draft, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.virtualDevice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
