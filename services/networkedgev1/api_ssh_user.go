/*
Network Edge APIs

Network Edge (NE) is a platform that allows customers to deploy and run virtual network services and appliances such as routers, load balancers, and firewalls on a generic device instead of additional dedicated hardware, CapEx and colo space. The Network Edge REST APIs allow you to interact with the Equinix Platform to programmatically create a virtual device and add services. Details on specific use cases can be found in the documentation available on the developer portal.

API version: 1.0
Contact: api-support@equinix.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package networkedgev1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SSHUserApiService SSHUserApi service
type SSHUserApiService service

type ApiAssociateDeviceUsingPOSTRequest struct {
	ctx           context.Context
	ApiService    *SSHUserApiService
	sshUserUuid   string
	deviceUuid    string
	authorization *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiAssociateDeviceUsingPOSTRequest) Authorization(authorization string) ApiAssociateDeviceUsingPOSTRequest {
	r.authorization = &authorization
	return r
}

func (r ApiAssociateDeviceUsingPOSTRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateDeviceUsingPOSTExecute(r)
}

/*
AssociateDeviceUsingPOST Update SSH User {uuid}

Call this API to associate a device to an SSH user. The ssh user should be able to log onto the device if this operation is successful.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sshUserUuid The id of the SSH user
	@param deviceUuid The unique Id of the device
	@return ApiAssociateDeviceUsingPOSTRequest
*/
func (a *SSHUserApiService) AssociateDeviceUsingPOST(ctx context.Context, sshUserUuid string, deviceUuid string) ApiAssociateDeviceUsingPOSTRequest {
	return ApiAssociateDeviceUsingPOSTRequest{
		ApiService:  a,
		ctx:         ctx,
		sshUserUuid: sshUserUuid,
		deviceUuid:  deviceUuid,
	}
}

// Execute executes the request
func (a *SSHUserApiService) AssociateDeviceUsingPOSTExecute(r ApiAssociateDeviceUsingPOSTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSHUserApiService.AssociateDeviceUsingPOST")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/sshUsers/{sshUserUuid}/devices/{deviceUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"sshUserUuid"+"}", url.PathEscape(parameterValueToString(r.sshUserUuid, "sshUserUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUuid"+"}", url.PathEscape(parameterValueToString(r.deviceUuid, "deviceUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateSshUserUsingPOSTRequest struct {
	ctx           context.Context
	ApiService    *SSHUserApiService
	authorization *string
	request       *SshUserCreateRequest
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiCreateSshUserUsingPOSTRequest) Authorization(authorization string) ApiCreateSshUserUsingPOSTRequest {
	r.authorization = &authorization
	return r
}

// SSH user info
func (r ApiCreateSshUserUsingPOSTRequest) Request(request SshUserCreateRequest) ApiCreateSshUserUsingPOSTRequest {
	r.request = &request
	return r
}

func (r ApiCreateSshUserUsingPOSTRequest) Execute() (*SshUserCreateResponse, *http.Response, error) {
	return r.ApiService.CreateSshUserUsingPOSTExecute(r)
}

/*
CreateSshUserUsingPOST Create SSH User

Creates a new SSH user and associates the user with a virtual device. Authorization checks are performed on users of this API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateSshUserUsingPOSTRequest
*/
func (a *SSHUserApiService) CreateSshUserUsingPOST(ctx context.Context) ApiCreateSshUserUsingPOSTRequest {
	return ApiCreateSshUserUsingPOSTRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SshUserCreateResponse
func (a *SSHUserApiService) CreateSshUserUsingPOSTExecute(r ApiCreateSshUserUsingPOSTRequest) (*SshUserCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SshUserCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSHUserApiService.CreateSshUserUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/sshUsers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDissociateDeviceUsingDELETERequest struct {
	ctx           context.Context
	ApiService    *SSHUserApiService
	sshUserUuid   string
	deviceUuid    string
	authorization *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiDissociateDeviceUsingDELETERequest) Authorization(authorization string) ApiDissociateDeviceUsingDELETERequest {
	r.authorization = &authorization
	return r
}

func (r ApiDissociateDeviceUsingDELETERequest) Execute() (*SshUserInfoDissociateResponse, *http.Response, error) {
	return r.ApiService.DissociateDeviceUsingDELETEExecute(r)
}

/*
DissociateDeviceUsingDELETE Delete SSH User

The given SSH user is dissociated from the given device. The ssh user is deleted if there are no other devices associated with this user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sshUserUuid uuid
	@param deviceUuid device unique Id
	@return ApiDissociateDeviceUsingDELETERequest
*/
func (a *SSHUserApiService) DissociateDeviceUsingDELETE(ctx context.Context, sshUserUuid string, deviceUuid string) ApiDissociateDeviceUsingDELETERequest {
	return ApiDissociateDeviceUsingDELETERequest{
		ApiService:  a,
		ctx:         ctx,
		sshUserUuid: sshUserUuid,
		deviceUuid:  deviceUuid,
	}
}

// Execute executes the request
//
//	@return SshUserInfoDissociateResponse
func (a *SSHUserApiService) DissociateDeviceUsingDELETEExecute(r ApiDissociateDeviceUsingDELETERequest) (*SshUserInfoDissociateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SshUserInfoDissociateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSHUserApiService.DissociateDeviceUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/sshUsers/{sshUserUuid}/devices/{deviceUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"sshUserUuid"+"}", url.PathEscape(parameterValueToString(r.sshUserUuid, "sshUserUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUuid"+"}", url.PathEscape(parameterValueToString(r.deviceUuid, "deviceUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSshUserUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SSHUserApiService
	uuid          string
	authorization *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetSshUserUsingGETRequest) Authorization(authorization string) ApiGetSshUserUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetSshUserUsingGETRequest) Execute() (*SshUserInfoVerbose, *http.Response, error) {
	return r.ApiService.GetSshUserUsingGETExecute(r)
}

/*
GetSshUserUsingGET Get SSH User {uuid}

Returns the ssh user details by its unique Id. Authorization checks are performed on the users of this API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid uuid
	@return ApiGetSshUserUsingGETRequest
*/
func (a *SSHUserApiService) GetSshUserUsingGET(ctx context.Context, uuid string) ApiGetSshUserUsingGETRequest {
	return ApiGetSshUserUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
//
//	@return SshUserInfoVerbose
func (a *SSHUserApiService) GetSshUserUsingGETExecute(r ApiGetSshUserUsingGETRequest) (*SshUserInfoVerbose, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SshUserInfoVerbose
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSHUserApiService.GetSshUserUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/sshUsers/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetSshUserUsingGET404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSshUsersUsingGETRequest struct {
	ctx               context.Context
	ApiService        *SSHUserApiService
	authorization     *string
	username          *string
	virtualDeviceUuid *string
	verbose           *bool
	accountUcmId      *string
	offset            *string
	limit             *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiGetSshUsersUsingGETRequest) Authorization(authorization string) ApiGetSshUsersUsingGETRequest {
	r.authorization = &authorization
	return r
}

// SSH user name
func (r ApiGetSshUsersUsingGETRequest) Username(username string) ApiGetSshUsersUsingGETRequest {
	r.username = &username
	return r
}

// Virtual Device unique Id
func (r ApiGetSshUsersUsingGETRequest) VirtualDeviceUuid(virtualDeviceUuid string) ApiGetSshUsersUsingGETRequest {
	r.virtualDeviceUuid = &virtualDeviceUuid
	return r
}

// Is detailed info required
func (r ApiGetSshUsersUsingGETRequest) Verbose(verbose bool) ApiGetSshUsersUsingGETRequest {
	r.verbose = &verbose
	return r
}

// Unique ID of an account
func (r ApiGetSshUsersUsingGETRequest) AccountUcmId(accountUcmId string) ApiGetSshUsersUsingGETRequest {
	r.accountUcmId = &accountUcmId
	return r
}

// Specifies where to start a page. It is the starting point of the collection returned from the server.
func (r ApiGetSshUsersUsingGETRequest) Offset(offset string) ApiGetSshUsersUsingGETRequest {
	r.offset = &offset
	return r
}

// Specifies the page size.
func (r ApiGetSshUsersUsingGETRequest) Limit(limit string) ApiGetSshUsersUsingGETRequest {
	r.limit = &limit
	return r
}

func (r ApiGetSshUsersUsingGETRequest) Execute() (*SshUserPageResponse, *http.Response, error) {
	return r.ApiService.GetSshUsersUsingGETExecute(r)
}

/*
GetSshUsersUsingGET Get SSH Users

Returns a list of all SSH Users associated with this account. Authorization checks are performed on the users of this API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSshUsersUsingGETRequest
*/
func (a *SSHUserApiService) GetSshUsersUsingGET(ctx context.Context) ApiGetSshUsersUsingGETRequest {
	return ApiGetSshUsersUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SshUserPageResponse
func (a *SSHUserApiService) GetSshUsersUsingGETExecute(r ApiGetSshUsersUsingGETRequest) (*SshUserPageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SshUserPageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSHUserApiService.GetSshUsersUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/sshUsers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	}
	if r.virtualDeviceUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualDeviceUuid", r.virtualDeviceUuid, "")
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "")
	}
	if r.accountUcmId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountUcmId", r.accountUcmId, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue string = "0"
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue string = "20"
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIsSshUserAvailableForCreationUsingGETRequest struct {
	ctx           context.Context
	ApiService    *SSHUserApiService
	username      *string
	authorization *string
}

// user name
func (r ApiIsSshUserAvailableForCreationUsingGETRequest) Username(username string) ApiIsSshUserAvailableForCreationUsingGETRequest {
	r.username = &username
	return r
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiIsSshUserAvailableForCreationUsingGETRequest) Authorization(authorization string) ApiIsSshUserAvailableForCreationUsingGETRequest {
	r.authorization = &authorization
	return r
}

func (r ApiIsSshUserAvailableForCreationUsingGETRequest) Execute() (*http.Response, error) {
	return r.ApiService.IsSshUserAvailableForCreationUsingGETExecute(r)
}

/*
IsSshUserAvailableForCreationUsingGET Check SSH Username Availability

Checks if an SSH username is available. Failed response indicates that the given username already exists or is restricted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIsSshUserAvailableForCreationUsingGETRequest
*/
func (a *SSHUserApiService) IsSshUserAvailableForCreationUsingGET(ctx context.Context) ApiIsSshUserAvailableForCreationUsingGETRequest {
	return ApiIsSshUserAvailableForCreationUsingGETRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SSHUserApiService) IsSshUserAvailableForCreationUsingGETExecute(r ApiIsSshUserAvailableForCreationUsingGETRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSHUserApiService.IsSshUserAvailableForCreationUsingGET")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/sshUsers/availability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.username == nil {
		return nil, reportError("username is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSshUserUsingPUTRequest struct {
	ctx           context.Context
	ApiService    *SSHUserApiService
	uuid          string
	authorization *string
	request       *SshUserUpdateRequest
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiUpdateSshUserUsingPUTRequest) Authorization(authorization string) ApiUpdateSshUserUsingPUTRequest {
	r.authorization = &authorization
	return r
}

// SSH user info
func (r ApiUpdateSshUserUsingPUTRequest) Request(request SshUserUpdateRequest) ApiUpdateSshUserUsingPUTRequest {
	r.request = &request
	return r
}

func (r ApiUpdateSshUserUsingPUTRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSshUserUsingPUTExecute(r)
}

/*
UpdateSshUserUsingPUT Update SSH User Password

Updates the password of an SSH user. Please pass the unique Id of the ssh user as a path parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid uuid
	@return ApiUpdateSshUserUsingPUTRequest
*/
func (a *SSHUserApiService) UpdateSshUserUsingPUT(ctx context.Context, uuid string) ApiUpdateSshUserUsingPUTRequest {
	return ApiUpdateSshUserUsingPUTRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
func (a *SSHUserApiService) UpdateSshUserUsingPUTExecute(r ApiUpdateSshUserUsingPUTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SSHUserApiService.UpdateSshUserUsingPUT")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ne/v1/sshUsers/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v FieldErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
