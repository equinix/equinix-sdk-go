/*
Lookup

Based on a user's permission, a user may view their locations, provider and patch panel in their organization. These locations can be filtered by permission code, account number, cage and cabinet details to get both A Side and Z side IBX locations and patch panel available ports to place an order

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lookupv2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// LookupApiService LookupApi service
type LookupApiService service

type ApiGetLocationsByPermissionCodeRequest struct {
	ctx                   context.Context
	ApiService            *LookupApiService
	permissionCode        *GetLocationsByPermissionCodePermissionCodeParameter
	ibxs                  *[]string
	providerAccountNumber *string
	aSideIbx              *string
	connectionService     *string
	details               *bool
}

// List of Permission code to be filtered
func (r ApiGetLocationsByPermissionCodeRequest) PermissionCode(permissionCode GetLocationsByPermissionCodePermissionCodeParameter) ApiGetLocationsByPermissionCodeRequest {
	r.permissionCode = &permissionCode
	return r
}

// List of IBXs to be filtered
func (r ApiGetLocationsByPermissionCodeRequest) Ibxs(ibxs []string) ApiGetLocationsByPermissionCodeRequest {
	r.ibxs = &ibxs
	return r
}

// The service provider&#39;s account number (Z-side) linked to their cage. Mandatory when used together with &#x60;aSideIbx&#x60;. This is only applicable when permissionCode is &#x60;CROSS_CONNECT&#x60;
func (r ApiGetLocationsByPermissionCodeRequest) ProviderAccountNumber(providerAccountNumber string) ApiGetLocationsByPermissionCodeRequest {
	r.providerAccountNumber = &providerAccountNumber
	return r
}

// A-Side IBX details to fetch the (Z-side). This is only applicable when permissionCode is &#x60;CROSS_CONNECT&#x60;
func (r ApiGetLocationsByPermissionCodeRequest) ASideIbx(aSideIbx string) ApiGetLocationsByPermissionCodeRequest {
	r.aSideIbx = &aSideIbx
	return r
}

// Type of connection service to fetch the Z-side details. This is only applicable when permissionCode is &#x60;CROSS_CONNECT&#x60; and is required when searching for zSide details.
func (r ApiGetLocationsByPermissionCodeRequest) ConnectionService(connectionService string) ApiGetLocationsByPermissionCodeRequest {
	r.connectionService = &connectionService
	return r
}

// When &#x60;true&#x60;, API response returns cage, cabinet and account details
func (r ApiGetLocationsByPermissionCodeRequest) Details(details bool) ApiGetLocationsByPermissionCodeRequest {
	r.details = &details
	return r
}

func (r ApiGetLocationsByPermissionCodeRequest) Execute() (*LocationsDetailsResponse, *http.Response, error) {
	return r.ApiService.GetLocationsByPermissionCodeExecute(r)
}

/*
GetLocationsByPermissionCode Get Locations by permission code

This method retrieves all the userâ€™s IBX locations, accounts, cages and cabinets information according to their ordering permission. This includes A-side and Z-side location information for a cross connect order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLocationsByPermissionCodeRequest
*/
func (a *LookupApiService) GetLocationsByPermissionCode(ctx context.Context) ApiGetLocationsByPermissionCodeRequest {
	return ApiGetLocationsByPermissionCodeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LocationsDetailsResponse
func (a *LookupApiService) GetLocationsByPermissionCodeExecute(r ApiGetLocationsByPermissionCodeRequest) (*LocationsDetailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LocationsDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LookupApiService.GetLocationsByPermissionCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocations/v2/locations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.permissionCode == nil {
		return localVarReturnValue, nil, reportError("permissionCode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionCode", r.permissionCode, "form", "")
	if r.ibxs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ibxs", r.ibxs, "form", "csv")
	}
	if r.providerAccountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerAccountNumber", r.providerAccountNumber, "form", "")
	}
	if r.aSideIbx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aSideIbx", r.aSideIbx, "form", "")
	}
	if r.connectionService != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionService", r.connectionService, "form", "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	} else {
		var defaultValue bool = false
		r.details = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveAllPatchPanelsRequest struct {
	ctx                   context.Context
	ApiService            *LookupApiService
	cabinetId             *string
	providerAccountNumber *string
	aSideIbx              *string
	accountNumber         *string
}

// ID of the cabinet
func (r ApiRetrieveAllPatchPanelsRequest) CabinetId(cabinetId string) ApiRetrieveAllPatchPanelsRequest {
	r.cabinetId = &cabinetId
	return r
}

// The service provider&#39;s account number (Z-side) linked to their cage. Mandatory when used together with &#x60;aSideIbx&#x60;
func (r ApiRetrieveAllPatchPanelsRequest) ProviderAccountNumber(providerAccountNumber string) ApiRetrieveAllPatchPanelsRequest {
	r.providerAccountNumber = &providerAccountNumber
	return r
}

// The IBX location code for A-Side. When used together with &#x60;providerAccountNumber&#x60;, this returns Z-side patch panel details.
func (r ApiRetrieveAllPatchPanelsRequest) ASideIbx(aSideIbx string) ApiRetrieveAllPatchPanelsRequest {
	r.aSideIbx = &aSideIbx
	return r
}

// Account number is only required when cabinet is shared.
func (r ApiRetrieveAllPatchPanelsRequest) AccountNumber(accountNumber string) ApiRetrieveAllPatchPanelsRequest {
	r.accountNumber = &accountNumber
	return r
}

func (r ApiRetrieveAllPatchPanelsRequest) Execute() ([]PatchPanelResponse, *http.Response, error) {
	return r.ApiService.RetrieveAllPatchPanelsExecute(r)
}

/*
RetrieveAllPatchPanels Retrieve all patch panels

This method retrieves all available patch panels associated with a cabinet for a user with cross connects ordering permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRetrieveAllPatchPanelsRequest
*/
func (a *LookupApiService) RetrieveAllPatchPanels(ctx context.Context) ApiRetrieveAllPatchPanelsRequest {
	return ApiRetrieveAllPatchPanelsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []PatchPanelResponse
func (a *LookupApiService) RetrieveAllPatchPanelsExecute(r ApiRetrieveAllPatchPanelsRequest) ([]PatchPanelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []PatchPanelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LookupApiService.RetrieveAllPatchPanels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocations/v2/patchPanels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cabinetId == nil {
		return localVarReturnValue, nil, reportError("cabinetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cabinetId", r.cabinetId, "form", "")
	if r.providerAccountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerAccountNumber", r.providerAccountNumber, "form", "")
	}
	if r.aSideIbx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aSideIbx", r.aSideIbx, "form", "")
	}
	if r.accountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNumber", r.accountNumber, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveListOfConnectionServicesRequest struct {
	ctx        context.Context
	ApiService *LookupApiService
	ibx        *string
}

// IBX
func (r ApiRetrieveListOfConnectionServicesRequest) Ibx(ibx string) ApiRetrieveListOfConnectionServicesRequest {
	r.ibx = &ibx
	return r
}

func (r ApiRetrieveListOfConnectionServicesRequest) Execute() ([]ConnectionServicesDetailsInner, *http.Response, error) {
	return r.ApiService.RetrieveListOfConnectionServicesExecute(r)
}

/*
RetrieveListOfConnectionServices Retrieve list of connection services

This method retrieves a list of supported connection services such as media types, protocol types, connector types and circuit counts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRetrieveListOfConnectionServicesRequest
*/
func (a *LookupApiService) RetrieveListOfConnectionServices(ctx context.Context) ApiRetrieveListOfConnectionServicesRequest {
	return ApiRetrieveListOfConnectionServicesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ConnectionServicesDetailsInner
func (a *LookupApiService) RetrieveListOfConnectionServicesExecute(r ApiRetrieveListOfConnectionServicesRequest) ([]ConnectionServicesDetailsInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ConnectionServicesDetailsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LookupApiService.RetrieveListOfConnectionServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocations/v2/connectionServices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveListOfProvidersRequest struct {
	ctx           context.Context
	ApiService    *LookupApiService
	cageId        *string
	accountNumber *string
}

// Cage ID
func (r ApiRetrieveListOfProvidersRequest) CageId(cageId string) ApiRetrieveListOfProvidersRequest {
	r.cageId = &cageId
	return r
}

// Account number of A-Side cage
func (r ApiRetrieveListOfProvidersRequest) AccountNumber(accountNumber string) ApiRetrieveListOfProvidersRequest {
	r.accountNumber = &accountNumber
	return r
}

func (r ApiRetrieveListOfProvidersRequest) Execute() ([]Provider, *http.Response, error) {
	return r.ApiService.RetrieveListOfProvidersExecute(r)
}

/*
RetrieveListOfProviders Retrieve list of providers

This method retrieves all available cross connect service providers to a user with cross connects ordering permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRetrieveListOfProvidersRequest
*/
func (a *LookupApiService) RetrieveListOfProviders(ctx context.Context) ApiRetrieveListOfProvidersRequest {
	return ApiRetrieveListOfProvidersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Provider
func (a *LookupApiService) RetrieveListOfProvidersExecute(r ApiRetrieveListOfProvidersRequest) ([]Provider, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LookupApiService.RetrieveListOfProviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocations/v2/providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cageId == nil {
		return localVarReturnValue, nil, reportError("cageId is required and must be specified")
	}
	if r.accountNumber == nil {
		return localVarReturnValue, nil, reportError("accountNumber is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cageId", r.cageId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNumber", r.accountNumber, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrievePatchPanelDetailsRequest struct {
	ctx                   context.Context
	ApiService            *LookupApiService
	patchPanelId          string
	providerAccountNumber *string
	aSideIbx              *string
	accountNumber         *string
}

// The service provider&#39;s account number (Z-side) linked to their cage. Mandatory when used together with &#x60;aSideIbx&#x60;
func (r ApiRetrievePatchPanelDetailsRequest) ProviderAccountNumber(providerAccountNumber string) ApiRetrievePatchPanelDetailsRequest {
	r.providerAccountNumber = &providerAccountNumber
	return r
}

// The IBX location code for A-Side. When used together with &#x60;providerAccountNumber&#x60; and &#x60;accountNumber&#x60;, this returns Z-side patch panel details.
func (r ApiRetrievePatchPanelDetailsRequest) ASideIbx(aSideIbx string) ApiRetrievePatchPanelDetailsRequest {
	r.aSideIbx = &aSideIbx
	return r
}

// A-Side cage account number
func (r ApiRetrievePatchPanelDetailsRequest) AccountNumber(accountNumber string) ApiRetrievePatchPanelDetailsRequest {
	r.accountNumber = &accountNumber
	return r
}

func (r ApiRetrievePatchPanelDetailsRequest) Execute() (*PatchPanelDetails, *http.Response, error) {
	return r.ApiService.RetrievePatchPanelDetailsExecute(r)
}

/*
RetrievePatchPanelDetails Retrieve patch panel details

This method retrieves details of a patch panel by its ID to a user with cross connects ordering permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param patchPanelId ID of patch panel
	@return ApiRetrievePatchPanelDetailsRequest
*/
func (a *LookupApiService) RetrievePatchPanelDetails(ctx context.Context, patchPanelId string) ApiRetrievePatchPanelDetailsRequest {
	return ApiRetrievePatchPanelDetailsRequest{
		ApiService:   a,
		ctx:          ctx,
		patchPanelId: patchPanelId,
	}
}

// Execute executes the request
//
//	@return PatchPanelDetails
func (a *LookupApiService) RetrievePatchPanelDetailsExecute(r ApiRetrievePatchPanelDetailsRequest) (*PatchPanelDetails, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PatchPanelDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LookupApiService.RetrievePatchPanelDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocations/v2/patchPanels/{patchPanelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"patchPanelId"+"}", url.PathEscape(parameterValueToString(r.patchPanelId, "patchPanelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.providerAccountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerAccountNumber", r.providerAccountNumber, "form", "")
	}
	if r.aSideIbx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aSideIbx", r.aSideIbx, "form", "")
	}
	if r.accountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNumber", r.accountNumber, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v [][]ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
