/*
Smart View Environmental API

Empower yourself with Environmental APIs. The API makes it possible to fetch current environmental data including humidity and temperature for a single sensor (identified by IBX code and sensor ID) or for all the sensors within an IBX (identified by IBX code) in a paginated way. When fetching all sensor readings you can apply additional sort criteria.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package smartview

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SmartViewAssetsApiService SmartViewAssetsApi service
type SmartViewAssetsApiService service

type ApiGetAffectedAssetRequest struct {
	ctx context.Context
	ApiService *SmartViewAssetsApiService
	authorization *string
	accountNo *string
	ibx *string
	assetId *string
	classification *GetAssetClassificationParameter
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiGetAffectedAssetRequest) Authorization(authorization string) ApiGetAffectedAssetRequest {
	r.authorization = &authorization
	return r
}

// customer account number
func (r ApiGetAffectedAssetRequest) AccountNo(accountNo string) ApiGetAffectedAssetRequest {
	r.accountNo = &accountNo
	return r
}

// ibx code
func (r ApiGetAffectedAssetRequest) Ibx(ibx string) ApiGetAffectedAssetRequest {
	r.ibx = &ibx
	return r
}

// asset id
func (r ApiGetAffectedAssetRequest) AssetId(assetId string) ApiGetAffectedAssetRequest {
	r.assetId = &assetId
	return r
}

// asset classification(Electrical, Mechanical)
func (r ApiGetAffectedAssetRequest) Classification(classification GetAssetClassificationParameter) ApiGetAffectedAssetRequest {
	r.classification = &classification
	return r
}

func (r ApiGetAffectedAssetRequest) Execute() (*HierarchyNode, *http.Response, error) {
	return r.ApiService.GetAffectedAssetExecute(r)
}

/*
GetAffectedAsset get affected customers assets hierarchy

The endpoint returns information regarding the affected assets of customers for a given asset identifier

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAffectedAssetRequest
*/
func (a *SmartViewAssetsApiService) GetAffectedAsset(ctx context.Context) ApiGetAffectedAssetRequest {
	return ApiGetAffectedAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HierarchyNode
func (a *SmartViewAssetsApiService) GetAffectedAssetExecute(r ApiGetAffectedAssetRequest) (*HierarchyNode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HierarchyNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewAssetsApiService.GetAffectedAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smartview/v1/asset/tagpoint/affected-assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}
	if r.classification == nil {
		return localVarReturnValue, nil, reportError("classification is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetRequest struct {
	ctx context.Context
	ApiService *SmartViewAssetsApiService
	authorization *string
	accountNo *string
	ibx *string
	classification *GetAssetClassificationParameter
	cages *[]string
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiGetAssetRequest) Authorization(authorization string) ApiGetAssetRequest {
	r.authorization = &authorization
	return r
}

// customer account number
func (r ApiGetAssetRequest) AccountNo(accountNo string) ApiGetAssetRequest {
	r.accountNo = &accountNo
	return r
}

// ibx code
func (r ApiGetAssetRequest) Ibx(ibx string) ApiGetAssetRequest {
	r.ibx = &ibx
	return r
}

// asset classification (Electrical, Mechanical)
func (r ApiGetAssetRequest) Classification(classification GetAssetClassificationParameter) ApiGetAssetRequest {
	r.classification = &classification
	return r
}

// cage unique space id to be used to filter the assets list assumed to be all cage unique space id if no value is sent. 
func (r ApiGetAssetRequest) Cages(cages []string) ApiGetAssetRequest {
	r.cages = &cages
	return r
}

func (r ApiGetAssetRequest) Execute() (*AssetsList, *http.Response, error) {
	return r.ApiService.GetAssetExecute(r)
}

/*
GetAsset get assets list information

This endpoint returns information about asset in a hierarchical structure ( category / template / asset ) based on the input account number, IBX code, cage and asset classification (Electrical, Mechanical).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetRequest
*/
func (a *SmartViewAssetsApiService) GetAsset(ctx context.Context) ApiGetAssetRequest {
	return ApiGetAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssetsList
func (a *SmartViewAssetsApiService) GetAssetExecute(r ApiGetAssetRequest) (*AssetsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewAssetsApiService.GetAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smartview/v1/asset/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.classification == nil {
		return localVarReturnValue, nil, reportError("classification is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	if r.cages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cages", r.cages, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetDetailsRequest struct {
	ctx context.Context
	ApiService *SmartViewAssetsApiService
	authorization *string
	accountNo *string
	ibx *string
	classification *string
	assetId *string
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiGetAssetDetailsRequest) Authorization(authorization string) ApiGetAssetDetailsRequest {
	r.authorization = &authorization
	return r
}

// customer account number
func (r ApiGetAssetDetailsRequest) AccountNo(accountNo string) ApiGetAssetDetailsRequest {
	r.accountNo = &accountNo
	return r
}

// ibx code
func (r ApiGetAssetDetailsRequest) Ibx(ibx string) ApiGetAssetDetailsRequest {
	r.ibx = &ibx
	return r
}

// asset classification (Electrical, Mechanical)
func (r ApiGetAssetDetailsRequest) Classification(classification string) ApiGetAssetDetailsRequest {
	r.classification = &classification
	return r
}

// asset id
func (r ApiGetAssetDetailsRequest) AssetId(assetId string) ApiGetAssetDetailsRequest {
	r.assetId = &assetId
	return r
}

func (r ApiGetAssetDetailsRequest) Execute() (*AssetDetailsGetResponse, *http.Response, error) {
	return r.ApiService.GetAssetDetailsExecute(r)
}

/*
GetAssetDetails get details for an asset.

This endpoint returns information about asset details including tag points lists for a given asset identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetDetailsRequest
*/
func (a *SmartViewAssetsApiService) GetAssetDetails(ctx context.Context) ApiGetAssetDetailsRequest {
	return ApiGetAssetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssetDetailsGetResponse
func (a *SmartViewAssetsApiService) GetAssetDetailsExecute(r ApiGetAssetDetailsRequest) (*AssetDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewAssetsApiService.GetAssetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smartview/v1/asset/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.classification == nil {
		return localVarReturnValue, nil, reportError("classification is required and must be specified")
	}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentTagPointRequest struct {
	ctx context.Context
	ApiService *SmartViewAssetsApiService
	authorization *string
	accountNo *string
	ibx *string
	tagid *string
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiGetCurrentTagPointRequest) Authorization(authorization string) ApiGetCurrentTagPointRequest {
	r.authorization = &authorization
	return r
}

// customer account number
func (r ApiGetCurrentTagPointRequest) AccountNo(accountNo string) ApiGetCurrentTagPointRequest {
	r.accountNo = &accountNo
	return r
}

// ibx code
func (r ApiGetCurrentTagPointRequest) Ibx(ibx string) ApiGetCurrentTagPointRequest {
	r.ibx = &ibx
	return r
}

// tag id is the unique identifier for the tag point
func (r ApiGetCurrentTagPointRequest) Tagid(tagid string) ApiGetCurrentTagPointRequest {
	r.tagid = &tagid
	return r
}

func (r ApiGetCurrentTagPointRequest) Execute() (*TagPointData, *http.Response, error) {
	return r.ApiService.GetCurrentTagPointExecute(r)
}

/*
GetCurrentTagPoint obtain latest tag point data

This endpoint fetches and provides the most recent tag point information for a given tag identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrentTagPointRequest
*/
func (a *SmartViewAssetsApiService) GetCurrentTagPoint(ctx context.Context) ApiGetCurrentTagPointRequest {
	return ApiGetCurrentTagPointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TagPointData
func (a *SmartViewAssetsApiService) GetCurrentTagPointExecute(r ApiGetCurrentTagPointRequest) (*TagPointData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagPointData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewAssetsApiService.GetCurrentTagPoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smartview/v1/asset/tagpoint/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.tagid == nil {
		return localVarReturnValue, nil, reportError("tagid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tagid", r.tagid, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagpointTrendingRequest struct {
	ctx context.Context
	ApiService *SmartViewAssetsApiService
	authorization *string
	accountNo *string
	ibx *string
	tagid *string
	interval *string
	fromDate *int32
	toDate *int32
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiGetTagpointTrendingRequest) Authorization(authorization string) ApiGetTagpointTrendingRequest {
	r.authorization = &authorization
	return r
}

// customer account number
func (r ApiGetTagpointTrendingRequest) AccountNo(accountNo string) ApiGetTagpointTrendingRequest {
	r.accountNo = &accountNo
	return r
}

// ibx code
func (r ApiGetTagpointTrendingRequest) Ibx(ibx string) ApiGetTagpointTrendingRequest {
	r.ibx = &ibx
	return r
}

// tag id is the unique identifier for the tag point
func (r ApiGetTagpointTrendingRequest) Tagid(tagid string) ApiGetTagpointTrendingRequest {
	r.tagid = &tagid
	return r
}

// tag point data interval (1h, 1d, reading)
func (r ApiGetTagpointTrendingRequest) Interval(interval string) ApiGetTagpointTrendingRequest {
	r.interval = &interval
	return r
}

// from date UTC time (1494345600000)
func (r ApiGetTagpointTrendingRequest) FromDate(fromDate int32) ApiGetTagpointTrendingRequest {
	r.fromDate = &fromDate
	return r
}

// to date UTC time (1494432000000)
func (r ApiGetTagpointTrendingRequest) ToDate(toDate int32) ApiGetTagpointTrendingRequest {
	r.toDate = &toDate
	return r
}

func (r ApiGetTagpointTrendingRequest) Execute() (*TagPointTrendingResponse, *http.Response, error) {
	return r.ApiService.GetTagpointTrendingExecute(r)
}

/*
GetTagpointTrending obtain trending tag point data

This endpoint fetches and returns the trending tag point information for a given tag identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTagpointTrendingRequest
*/
func (a *SmartViewAssetsApiService) GetTagpointTrending(ctx context.Context) ApiGetTagpointTrendingRequest {
	return ApiGetTagpointTrendingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TagPointTrendingResponse
func (a *SmartViewAssetsApiService) GetTagpointTrendingExecute(r ApiGetTagpointTrendingRequest) (*TagPointTrendingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagPointTrendingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewAssetsApiService.GetTagpointTrending")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smartview/v1/asset/tagpoint/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.tagid == nil {
		return localVarReturnValue, nil, reportError("tagid is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}
	if r.fromDate == nil {
		return localVarReturnValue, nil, reportError("fromDate is required and must be specified")
	}
	if r.toDate == nil {
		return localVarReturnValue, nil, reportError("toDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tagid", r.tagid, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMixin4Request struct {
	ctx context.Context
	ApiService *SmartViewAssetsApiService
	authorization *string
	payload *AssetDetailsRequest
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiMixin4Request) Authorization(authorization string) ApiMixin4Request {
	r.authorization = &authorization
	return r
}

// request schema
func (r ApiMixin4Request) Payload(payload AssetDetailsRequest) ApiMixin4Request {
	r.payload = &payload
	return r
}

func (r ApiMixin4Request) Execute() (*AssetDetailsResponse, *http.Response, error) {
	return r.ApiService.Mixin4Execute(r)
}

/*
Mixin4 get asset details

This endpoint returns information about assets details including the assets tag points list for the given multiple asset identifiers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMixin4Request
*/
func (a *SmartViewAssetsApiService) Mixin4(ctx context.Context) ApiMixin4Request {
	return ApiMixin4Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssetDetailsResponse
func (a *SmartViewAssetsApiService) Mixin4Execute(r ApiMixin4Request) (*AssetDetailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewAssetsApiService.Mixin4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smartview/v1/asset/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMixin4_0Request struct {
	ctx context.Context
	ApiService *SmartViewAssetsApiService
	authorization *string
	payload *CurrentTagPointRequest
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiMixin4_0Request) Authorization(authorization string) ApiMixin4_0Request {
	r.authorization = &authorization
	return r
}

func (r ApiMixin4_0Request) Payload(payload CurrentTagPointRequest) ApiMixin4_0Request {
	r.payload = &payload
	return r
}

func (r ApiMixin4_0Request) Execute() (*TagPointData, *http.Response, error) {
	return r.ApiService.Mixin4_1Execute(r)
}

/*
Mixin4_0 get current tag points data

This endpoint fetches the latest read values for given tag points using given tag identifiers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMixin4_0Request
*/
func (a *SmartViewAssetsApiService) Mixin4_1(ctx context.Context) ApiMixin4_0Request {
	return ApiMixin4_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TagPointData
func (a *SmartViewAssetsApiService) Mixin4_1Execute(r ApiMixin4_0Request) (*TagPointData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagPointData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewAssetsApiService.Mixin4_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smartview/v1/asset/tagpoint/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAssetRequest struct {
	ctx context.Context
	ApiService *SmartViewAssetsApiService
	authorization *string
	accountNo *string
	ibx *string
	searchString *string
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiSearchAssetRequest) Authorization(authorization string) ApiSearchAssetRequest {
	r.authorization = &authorization
	return r
}

// Customer Account Number
func (r ApiSearchAssetRequest) AccountNo(accountNo string) ApiSearchAssetRequest {
	r.accountNo = &accountNo
	return r
}

// IBX Code
func (r ApiSearchAssetRequest) Ibx(ibx string) ApiSearchAssetRequest {
	r.ibx = &ibx
	return r
}

// Search String
func (r ApiSearchAssetRequest) SearchString(searchString string) ApiSearchAssetRequest {
	r.searchString = &searchString
	return r
}

func (r ApiSearchAssetRequest) Execute() (*Assets, *http.Response, error) {
	return r.ApiService.SearchAssetExecute(r)
}

/*
SearchAsset Search for Assets matching identifiers

This endpoint is used to search for assets using wild card search patterns matching the asset identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchAssetRequest
*/
func (a *SmartViewAssetsApiService) SearchAsset(ctx context.Context) ApiSearchAssetRequest {
	return ApiSearchAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Assets
func (a *SmartViewAssetsApiService) SearchAssetExecute(r ApiSearchAssetRequest) (*Assets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Assets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewAssetsApiService.SearchAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smartview/v1/asset/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.searchString == nil {
		return localVarReturnValue, nil, reportError("searchString is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "searchString", r.searchString, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
