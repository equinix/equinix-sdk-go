/*
DCIM Power APIs

Empower yourself with DCIM Power APIs. Use them to get current and trending information on power consumption by assets. These APIs return the power consumption info for all level values, given a customer account number, IBX and level type of ibx - cage, cabinet or circuit. Trending power data returns the kVA power draw and max allowed (%) for the given asset. 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package smartview

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


// SmartViewEnvironmentApiService SmartViewEnvironmentApi service
type SmartViewEnvironmentApiService service

type ApiMixin0Request struct {
	ctx context.Context
	ApiService *SmartViewEnvironmentApiService
	authorization *string
	accountNo *string
	ibx *string
	levelType *Mixin0LevelTypeParameter
	levelValue *string
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiMixin0Request) Authorization(authorization string) ApiMixin0Request {
	r.authorization = &authorization
	return r
}

// Customer Account Number
func (r ApiMixin0Request) AccountNo(accountNo string) ApiMixin0Request {
	r.accountNo = &accountNo
	return r
}

// IBX Code
func (r ApiMixin0Request) Ibx(ibx string) ApiMixin0Request {
	r.ibx = &ibx
	return r
}

// Level Type
func (r ApiMixin0Request) LevelType(levelType Mixin0LevelTypeParameter) ApiMixin0Request {
	r.levelType = &levelType
	return r
}

// Level Value is ibxCode, zoneUsID, cageUsID, sensorid for  levelType ibx, zone, cage, sensor resp. 
func (r ApiMixin0Request) LevelValue(levelValue string) ApiMixin0Request {
	r.levelValue = &levelValue
	return r
}

func (r ApiMixin0Request) Execute() (*EnvironmentData, *http.Response, error) {
	return r.ApiService.Mixin0Execute(r)
}

/*
Mixin0 Get current environmental data

The endpoint returns environment information on temperature and humidity from inputs (ibx, zone, cage, sensor)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMixin0Request
*/
func (a *SmartViewEnvironmentApiService) Mixin0(ctx context.Context) ApiMixin0Request {
	return ApiMixin0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EnvironmentData
func (a *SmartViewEnvironmentApiService) Mixin0Execute(r ApiMixin0Request) (*EnvironmentData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvironmentData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewEnvironmentApiService.Mixin0")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/v1/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.levelType == nil {
		return localVarReturnValue, nil, reportError("levelType is required and must be specified")
	}
	if r.levelValue == nil {
		return localVarReturnValue, nil, reportError("levelValue is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelType", r.levelType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelValue", r.levelValue, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMixin0_0Request struct {
	ctx context.Context
	ApiService *SmartViewEnvironmentApiService
	authorization *string
	accountNo *string
	ibx *string
	levelType *Mixin0LevelTypeParameter
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiMixin0_0Request) Authorization(authorization string) ApiMixin0_0Request {
	r.authorization = &authorization
	return r
}

// Customer Account Number
func (r ApiMixin0_0Request) AccountNo(accountNo string) ApiMixin0_0Request {
	r.accountNo = &accountNo
	return r
}

// IBX Code
func (r ApiMixin0_0Request) Ibx(ibx string) ApiMixin0_0Request {
	r.ibx = &ibx
	return r
}

// Level Type
func (r ApiMixin0_0Request) LevelType(levelType Mixin0LevelTypeParameter) ApiMixin0_0Request {
	r.levelType = &levelType
	return r
}

func (r ApiMixin0_0Request) Execute() (*EnvironmentDataResponse, *http.Response, error) {
	return r.ApiService.Mixin0_1Execute(r)
}

/*
Mixin0_0 Fetch list of environmental data

The GET endpoint returns environment info ( humidity and temperature ) for all the values for input level type  IBX, ZONE, CAGE, SENSOR


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMixin0_0Request
*/
func (a *SmartViewEnvironmentApiService) Mixin0_1(ctx context.Context) ApiMixin0_0Request {
	return ApiMixin0_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EnvironmentDataResponse
func (a *SmartViewEnvironmentApiService) Mixin0_1Execute(r ApiMixin0_0Request) (*EnvironmentDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvironmentDataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewEnvironmentApiService.Mixin0_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/v1/listCurrent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.levelType == nil {
		return localVarReturnValue, nil, reportError("levelType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelType", r.levelType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMixin0_1Request struct {
	ctx context.Context
	ApiService *SmartViewEnvironmentApiService
	authorization *string
	accountNo *string
	ibx *float32
	dataPoint *Mixin0DataPointParameter
	levelType *Mixin0LevelTypeParameter
	levelValue *string
	interval *Mixin0IntervalParameter
	fromDate *time.Time
	toDate *time.Time
}

// The OAuth Bearer token. Please add the prefix &#39;Bearer &#39; before the token.
func (r ApiMixin0_1Request) Authorization(authorization string) ApiMixin0_1Request {
	r.authorization = &authorization
	return r
}

// Customer Account Number
func (r ApiMixin0_1Request) AccountNo(accountNo string) ApiMixin0_1Request {
	r.accountNo = &accountNo
	return r
}

// IBX Code
func (r ApiMixin0_1Request) Ibx(ibx float32) ApiMixin0_1Request {
	r.ibx = &ibx
	return r
}

// data point
func (r ApiMixin0_1Request) DataPoint(dataPoint Mixin0DataPointParameter) ApiMixin0_1Request {
	r.dataPoint = &dataPoint
	return r
}

// Level Type
func (r ApiMixin0_1Request) LevelType(levelType Mixin0LevelTypeParameter) ApiMixin0_1Request {
	r.levelType = &levelType
	return r
}

// Level Value is ibxCode, zone, cage, sensorid for  levelType ibx, zone, cage, sensor resp. 
func (r ApiMixin0_1Request) LevelValue(levelValue string) ApiMixin0_1Request {
	r.levelValue = &levelValue
	return r
}

func (r ApiMixin0_1Request) Interval(interval Mixin0IntervalParameter) ApiMixin0_1Request {
	r.interval = &interval
	return r
}

// date in long
func (r ApiMixin0_1Request) FromDate(fromDate time.Time) ApiMixin0_1Request {
	r.fromDate = &fromDate
	return r
}

// date in long
func (r ApiMixin0_1Request) ToDate(toDate time.Time) ApiMixin0_1Request {
	r.toDate = &toDate
	return r
}

func (r ApiMixin0_1Request) Execute() (*TrendingEnvironmentData, *http.Response, error) {
	return r.ApiService.Mixin0_2Execute(r)
}

/*
Mixin0_1 Fetch trending environmental data

The endpoint returns trending environment information (temperature and humidity) for
input ibx, zone, cage, sensor  


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMixin0_1Request
*/
func (a *SmartViewEnvironmentApiService) Mixin0_2(ctx context.Context) ApiMixin0_1Request {
	return ApiMixin0_1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrendingEnvironmentData
func (a *SmartViewEnvironmentApiService) Mixin0_2Execute(r ApiMixin0_1Request) (*TrendingEnvironmentData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrendingEnvironmentData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmartViewEnvironmentApiService.Mixin0_2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment/v1/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.dataPoint == nil {
		return localVarReturnValue, nil, reportError("dataPoint is required and must be specified")
	}
	if r.levelType == nil {
		return localVarReturnValue, nil, reportError("levelType is required and must be specified")
	}
	if r.levelValue == nil {
		return localVarReturnValue, nil, reportError("levelValue is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}
	if r.fromDate == nil {
		return localVarReturnValue, nil, reportError("fromDate is required and must be specified")
	}
	if r.toDate == nil {
		return localVarReturnValue, nil, reportError("toDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dataPoint", r.dataPoint, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelType", r.levelType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelValue", r.levelValue, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
