/*
DCIM Power APIs

Empower yourself with DCIM Power APIs. Use them to get current and trending information on power consumption by assets. These APIs return the power consumption info for all level values, given a customer account number, IBX and level type of ibx - cage, cabinet or circuit. Trending power data returns the kVA power draw and max allowed (%) for the given asset. 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package smartview

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DCIMPowerApiService DCIMPowerApi service
type DCIMPowerApiService service

type ApiPowerV1CurrentGetRequest struct {
	ctx context.Context
	ApiService *DCIMPowerApiService
	authorization *string
	accountNo *string
	ibx *string
	levelType *PowerV1CurrentGetLevelTypeParameter
	levelValue *string
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiPowerV1CurrentGetRequest) Authorization(authorization string) ApiPowerV1CurrentGetRequest {
	r.authorization = &authorization
	return r
}

// Customer Account Number
func (r ApiPowerV1CurrentGetRequest) AccountNo(accountNo string) ApiPowerV1CurrentGetRequest {
	r.accountNo = &accountNo
	return r
}

// IBX Code
func (r ApiPowerV1CurrentGetRequest) Ibx(ibx string) ApiPowerV1CurrentGetRequest {
	r.ibx = &ibx
	return r
}

// level type allowed value [ibx|cage|cabinet|circuit]
func (r ApiPowerV1CurrentGetRequest) LevelType(levelType PowerV1CurrentGetLevelTypeParameter) ApiPowerV1CurrentGetRequest {
	r.levelType = &levelType
	return r
}

// level value - ibx code, cage unique space id, cabinet unique space id, serial number for level type ibx, cage, cabinet, circuit respectively. 
func (r ApiPowerV1CurrentGetRequest) LevelValue(levelValue string) ApiPowerV1CurrentGetRequest {
	r.levelValue = &levelValue
	return r
}

func (r ApiPowerV1CurrentGetRequest) Execute() (*PowerData, *http.Response, error) {
	return r.ApiService.PowerV1CurrentGetExecute(r)
}

/*
PowerV1CurrentGet Fetch current power consumption data

The powerData endpoint returns power consumption info ( power consumption data with comparison data of current [% Kva] vs  yesterday, lastWeek, lastMonth, lastQuarter ) for input ibx, cage, cabinet, circuit.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPowerV1CurrentGetRequest
*/
func (a *DCIMPowerApiService) PowerV1CurrentGet(ctx context.Context) ApiPowerV1CurrentGetRequest {
	return ApiPowerV1CurrentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerData
func (a *DCIMPowerApiService) PowerV1CurrentGetExecute(r ApiPowerV1CurrentGetRequest) (*PowerData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DCIMPowerApiService.PowerV1CurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/power/v1/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.levelType == nil {
		return localVarReturnValue, nil, reportError("levelType is required and must be specified")
	}
	if r.levelValue == nil {
		return localVarReturnValue, nil, reportError("levelValue is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelType", r.levelType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelValue", r.levelValue, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v PowerDataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPowerV1CurrentPostRequest struct {
	ctx context.Context
	ApiService *DCIMPowerApiService
	authorization *string
	body *PowerCurrentPostRequest
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiPowerV1CurrentPostRequest) Authorization(authorization string) ApiPowerV1CurrentPostRequest {
	r.authorization = &authorization
	return r
}

// request payload
func (r ApiPowerV1CurrentPostRequest) Body(body PowerCurrentPostRequest) ApiPowerV1CurrentPostRequest {
	r.body = &body
	return r
}

func (r ApiPowerV1CurrentPostRequest) Execute() (*PowerDataResponseIBX, *http.Response, error) {
	return r.ApiService.PowerV1CurrentPostExecute(r)
}

/*
PowerV1CurrentPost Fetch current power consumption data

The powerdata endpoint returns power consumption info for all values of input level type ibx, cage, cabinet or circuit.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPowerV1CurrentPostRequest
*/
func (a *DCIMPowerApiService) PowerV1CurrentPost(ctx context.Context) ApiPowerV1CurrentPostRequest {
	return ApiPowerV1CurrentPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PowerDataResponseIBX
func (a *DCIMPowerApiService) PowerV1CurrentPostExecute(r ApiPowerV1CurrentPostRequest) (*PowerDataResponseIBX, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PowerDataResponseIBX
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DCIMPowerApiService.PowerV1CurrentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/power/v1/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v PowerDataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPowerV1TrendingGetRequest struct {
	ctx context.Context
	ApiService *DCIMPowerApiService
	authorization *string
	accountNo *string
	ibx *float32
	levelType *PowerV1CurrentGetLevelTypeParameter
	levelValue *string
	interval *string
	fromDate *string
	toDate *string
}

// Specify the OAuth Bearer token with prefix &#39;Bearer &#39;.
func (r ApiPowerV1TrendingGetRequest) Authorization(authorization string) ApiPowerV1TrendingGetRequest {
	r.authorization = &authorization
	return r
}

// Customer Account Number
func (r ApiPowerV1TrendingGetRequest) AccountNo(accountNo string) ApiPowerV1TrendingGetRequest {
	r.accountNo = &accountNo
	return r
}

// IBX Code
func (r ApiPowerV1TrendingGetRequest) Ibx(ibx float32) ApiPowerV1TrendingGetRequest {
	r.ibx = &ibx
	return r
}

// [ibx|cage|cabinet|circuit]
func (r ApiPowerV1TrendingGetRequest) LevelType(levelType PowerV1CurrentGetLevelTypeParameter) ApiPowerV1TrendingGetRequest {
	r.levelType = &levelType
	return r
}

// ibx code, cage unique space id, cabinet unique space id and serial number for level type ibx, cage, cabinet and circuit respectively. 
func (r ApiPowerV1TrendingGetRequest) LevelValue(levelValue string) ApiPowerV1TrendingGetRequest {
	r.levelValue = &levelValue
	return r
}

// [recording|1h|1d]
func (r ApiPowerV1TrendingGetRequest) Interval(interval string) ApiPowerV1TrendingGetRequest {
	r.interval = &interval
	return r
}

// timestamp expected to be epoch long ( milliseconds ).
func (r ApiPowerV1TrendingGetRequest) FromDate(fromDate string) ApiPowerV1TrendingGetRequest {
	r.fromDate = &fromDate
	return r
}

// timestamp expected to be epoch long ( milliseconds ).
func (r ApiPowerV1TrendingGetRequest) ToDate(toDate string) ApiPowerV1TrendingGetRequest {
	r.toDate = &toDate
	return r
}

func (r ApiPowerV1TrendingGetRequest) Execute() (*TrendingPowerData, *http.Response, error) {
	return r.ApiService.PowerV1TrendingGetExecute(r)
}

/*
PowerV1TrendingGet Fetch Trending Power Data. 

The trending power data for draw kVA to max allowed (%) for input ibx, cage, cabinet, circuit.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPowerV1TrendingGetRequest
*/
func (a *DCIMPowerApiService) PowerV1TrendingGet(ctx context.Context) ApiPowerV1TrendingGetRequest {
	return ApiPowerV1TrendingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrendingPowerData
func (a *DCIMPowerApiService) PowerV1TrendingGetExecute(r ApiPowerV1TrendingGetRequest) (*TrendingPowerData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrendingPowerData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DCIMPowerApiService.PowerV1TrendingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/power/v1/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.accountNo == nil {
		return localVarReturnValue, nil, reportError("accountNo is required and must be specified")
	}
	if r.ibx == nil {
		return localVarReturnValue, nil, reportError("ibx is required and must be specified")
	}
	if r.levelType == nil {
		return localVarReturnValue, nil, reportError("levelType is required and must be specified")
	}
	if r.levelValue == nil {
		return localVarReturnValue, nil, reportError("levelValue is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}
	if r.fromDate == nil {
		return localVarReturnValue, nil, reportError("fromDate is required and must be specified")
	}
	if r.toDate == nil {
		return localVarReturnValue, nil, reportError("toDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ibx", r.ibx, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelType", r.levelType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelValue", r.levelValue, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v PowerDataError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
