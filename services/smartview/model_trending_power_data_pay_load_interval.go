/*
DCIM Power APIs

Empower yourself with DCIM Power APIs. Use them to get current and trending information on power consumption by assets. These APIs return the power consumption info for all level values, given a customer account number, IBX and level type of ibx - cage, cabinet or circuit. Trending power data returns the kVA power draw and max allowed (%) for the given asset. 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package smartview

import (
	"encoding/json"
	"fmt"
)

// TrendingPowerDataPayLoadInterval serial number
type TrendingPowerDataPayLoadInterval string

// List of TrendingPowerData_payLoad_interval
const (
	TRENDINGPOWERDATAPAYLOADINTERVAL__5M TrendingPowerDataPayLoadInterval = "5m"
	TRENDINGPOWERDATAPAYLOADINTERVAL__15M TrendingPowerDataPayLoadInterval = "15m"
	TRENDINGPOWERDATAPAYLOADINTERVAL__1H TrendingPowerDataPayLoadInterval = "1h"
	TRENDINGPOWERDATAPAYLOADINTERVAL__1D TrendingPowerDataPayLoadInterval = "1d"
)

// All allowed values of TrendingPowerDataPayLoadInterval enum
var AllowedTrendingPowerDataPayLoadIntervalEnumValues = []TrendingPowerDataPayLoadInterval{
	"5m",
	"15m",
	"1h",
	"1d",
}

func (v *TrendingPowerDataPayLoadInterval) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := TrendingPowerDataPayLoadInterval(value)
	for _, existing := range AllowedTrendingPowerDataPayLoadIntervalEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid TrendingPowerDataPayLoadInterval", value)
}

// NewTrendingPowerDataPayLoadIntervalFromValue returns a pointer to a valid TrendingPowerDataPayLoadInterval
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewTrendingPowerDataPayLoadIntervalFromValue(v string) (*TrendingPowerDataPayLoadInterval, error) {
	ev := TrendingPowerDataPayLoadInterval(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for TrendingPowerDataPayLoadInterval: valid values are %v", v, AllowedTrendingPowerDataPayLoadIntervalEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v TrendingPowerDataPayLoadInterval) IsValid() bool {
	for _, existing := range AllowedTrendingPowerDataPayLoadIntervalEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to TrendingPowerData_payLoad_interval value
func (v TrendingPowerDataPayLoadInterval) Ptr() *TrendingPowerDataPayLoadInterval {
	return &v
}

type NullableTrendingPowerDataPayLoadInterval struct {
	value *TrendingPowerDataPayLoadInterval
	isSet bool
}

func (v NullableTrendingPowerDataPayLoadInterval) Get() *TrendingPowerDataPayLoadInterval {
	return v.value
}

func (v *NullableTrendingPowerDataPayLoadInterval) Set(val *TrendingPowerDataPayLoadInterval) {
	v.value = val
	v.isSet = true
}

func (v NullableTrendingPowerDataPayLoadInterval) IsSet() bool {
	return v.isSet
}

func (v *NullableTrendingPowerDataPayLoadInterval) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTrendingPowerDataPayLoadInterval(val *TrendingPowerDataPayLoadInterval) *NullableTrendingPowerDataPayLoadInterval {
	return &NullableTrendingPowerDataPayLoadInterval{value: val, isSet: true}
}

func (v NullableTrendingPowerDataPayLoadInterval) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTrendingPowerDataPayLoadInterval) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

