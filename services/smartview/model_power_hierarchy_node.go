/*
DCIM Power APIs

Empower yourself with DCIM Power APIs. Use them to get current and trending information on power consumption by assets. These APIs return the power consumption info for all level values, given a customer account number, IBX and level type of ibx - cage, cabinet or circuit. Trending power data returns the kVA power draw and max allowed (%) for the given asset. 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package smartview

import (
	"encoding/json"
)

// checks if the PowerHierarchyNode type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &PowerHierarchyNode{}

// PowerHierarchyNode struct for PowerHierarchyNode
type PowerHierarchyNode struct {
	// ibx, cage, cabinet nodes can have cage, cabinet and circuit,  circuit nodes as children respectively. 
	Children []PowerHierarchyNode `json:"children,omitempty"`
	// ibx code, cage unique space id, cabinet unique space id, circuit label for levelType ibx, cage, cabinet, circuit resp. 
	Label *string `json:"label,omitempty"`
	LevelType *PowerHierarchyNodeLevelType `json:"levelType,omitempty"`
	// ibx code, cage us id, cabinet us id, circuit number for  levelType ibx, cage, cabinet, circuit resp. 
	LevelValue *string `json:"levelValue,omitempty"`
	AdditionalProperties map[string]interface{}
}

type _PowerHierarchyNode PowerHierarchyNode

// NewPowerHierarchyNode instantiates a new PowerHierarchyNode object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewPowerHierarchyNode() *PowerHierarchyNode {
	this := PowerHierarchyNode{}
	return &this
}

// NewPowerHierarchyNodeWithDefaults instantiates a new PowerHierarchyNode object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewPowerHierarchyNodeWithDefaults() *PowerHierarchyNode {
	this := PowerHierarchyNode{}
	return &this
}

// GetChildren returns the Children field value if set, zero value otherwise.
func (o *PowerHierarchyNode) GetChildren() []PowerHierarchyNode {
	if o == nil || IsNil(o.Children) {
		var ret []PowerHierarchyNode
		return ret
	}
	return o.Children
}

// GetChildrenOk returns a tuple with the Children field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *PowerHierarchyNode) GetChildrenOk() ([]PowerHierarchyNode, bool) {
	if o == nil || IsNil(o.Children) {
		return nil, false
	}
	return o.Children, true
}

// HasChildren returns a boolean if a field has been set.
func (o *PowerHierarchyNode) HasChildren() bool {
	if o != nil && !IsNil(o.Children) {
		return true
	}

	return false
}

// SetChildren gets a reference to the given []PowerHierarchyNode and assigns it to the Children field.
func (o *PowerHierarchyNode) SetChildren(v []PowerHierarchyNode) {
	o.Children = v
}

// GetLabel returns the Label field value if set, zero value otherwise.
func (o *PowerHierarchyNode) GetLabel() string {
	if o == nil || IsNil(o.Label) {
		var ret string
		return ret
	}
	return *o.Label
}

// GetLabelOk returns a tuple with the Label field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *PowerHierarchyNode) GetLabelOk() (*string, bool) {
	if o == nil || IsNil(o.Label) {
		return nil, false
	}
	return o.Label, true
}

// HasLabel returns a boolean if a field has been set.
func (o *PowerHierarchyNode) HasLabel() bool {
	if o != nil && !IsNil(o.Label) {
		return true
	}

	return false
}

// SetLabel gets a reference to the given string and assigns it to the Label field.
func (o *PowerHierarchyNode) SetLabel(v string) {
	o.Label = &v
}

// GetLevelType returns the LevelType field value if set, zero value otherwise.
func (o *PowerHierarchyNode) GetLevelType() PowerHierarchyNodeLevelType {
	if o == nil || IsNil(o.LevelType) {
		var ret PowerHierarchyNodeLevelType
		return ret
	}
	return *o.LevelType
}

// GetLevelTypeOk returns a tuple with the LevelType field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *PowerHierarchyNode) GetLevelTypeOk() (*PowerHierarchyNodeLevelType, bool) {
	if o == nil || IsNil(o.LevelType) {
		return nil, false
	}
	return o.LevelType, true
}

// HasLevelType returns a boolean if a field has been set.
func (o *PowerHierarchyNode) HasLevelType() bool {
	if o != nil && !IsNil(o.LevelType) {
		return true
	}

	return false
}

// SetLevelType gets a reference to the given PowerHierarchyNodeLevelType and assigns it to the LevelType field.
func (o *PowerHierarchyNode) SetLevelType(v PowerHierarchyNodeLevelType) {
	o.LevelType = &v
}

// GetLevelValue returns the LevelValue field value if set, zero value otherwise.
func (o *PowerHierarchyNode) GetLevelValue() string {
	if o == nil || IsNil(o.LevelValue) {
		var ret string
		return ret
	}
	return *o.LevelValue
}

// GetLevelValueOk returns a tuple with the LevelValue field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *PowerHierarchyNode) GetLevelValueOk() (*string, bool) {
	if o == nil || IsNil(o.LevelValue) {
		return nil, false
	}
	return o.LevelValue, true
}

// HasLevelValue returns a boolean if a field has been set.
func (o *PowerHierarchyNode) HasLevelValue() bool {
	if o != nil && !IsNil(o.LevelValue) {
		return true
	}

	return false
}

// SetLevelValue gets a reference to the given string and assigns it to the LevelValue field.
func (o *PowerHierarchyNode) SetLevelValue(v string) {
	o.LevelValue = &v
}

func (o PowerHierarchyNode) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o PowerHierarchyNode) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Children) {
		toSerialize["children"] = o.Children
	}
	if !IsNil(o.Label) {
		toSerialize["label"] = o.Label
	}
	if !IsNil(o.LevelType) {
		toSerialize["levelType"] = o.LevelType
	}
	if !IsNil(o.LevelValue) {
		toSerialize["levelValue"] = o.LevelValue
	}

	for key, value := range o.AdditionalProperties {
		toSerialize[key] = value
	}

	return toSerialize, nil
}

func (o *PowerHierarchyNode) UnmarshalJSON(data []byte) (err error) {
	varPowerHierarchyNode := _PowerHierarchyNode{}

	err = json.Unmarshal(data, &varPowerHierarchyNode)

	if err != nil {
		return err
	}

	*o = PowerHierarchyNode(varPowerHierarchyNode)

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(data, &additionalProperties); err == nil {
		delete(additionalProperties, "children")
		delete(additionalProperties, "label")
		delete(additionalProperties, "levelType")
		delete(additionalProperties, "levelValue")
		o.AdditionalProperties = additionalProperties
	}

	return err
}

type NullablePowerHierarchyNode struct {
	value *PowerHierarchyNode
	isSet bool
}

func (v NullablePowerHierarchyNode) Get() *PowerHierarchyNode {
	return v.value
}

func (v *NullablePowerHierarchyNode) Set(val *PowerHierarchyNode) {
	v.value = val
	v.isSet = true
}

func (v NullablePowerHierarchyNode) IsSet() bool {
	return v.isSet
}

func (v *NullablePowerHierarchyNode) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePowerHierarchyNode(val *PowerHierarchyNode) *NullablePowerHierarchyNode {
	return &NullablePowerHierarchyNode{value: val, isSet: true}
}

func (v NullablePowerHierarchyNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePowerHierarchyNode) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


